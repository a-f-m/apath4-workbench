var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"a.html","title":"a...","text":""},{"location":"a.html#a1","title":"a1...","text":""},{"location":"b.html","title":"b...","text":""},{"location":"b.html#b1","title":"b1...","text":""},{"location":"c.html","title":"c...","text":""},{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. </p> <p>Moreover, variables enable reuse of existing values whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax is well-defined, using Parsing Expression Grammars and Abstract Data Types, respectively. Implementation follows the concept of transpilation (for now to JavaScript) that ensures performant execution and can be adapted to support other target languages.</p> <p>Specification and development is in progress, so every feature described here will be implemented step by step.</p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, apath will offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"...forthcoming...","text":""},{"location":"language/grammar.html","title":"Description by Grammar","text":"<p>apath is an expression language, so the start rule is of coarse Expression. For instance, <code>person.age == 18</code> checks equality of a value of a path with a literal value. Because a path with steps is the most used and central construct, the grammar here will start on this level.</p> <p>The grammar will be described top-down<sup>1</sup>. Icon  shows the related cheat-sheet part.</p>"},{"location":"language/grammar.html#paths","title":"Paths","text":"<p>A path is a 'dot'-separated sequence of composite steps. Every step yields a sequence of nodes that are passed one by one to the subsequent step. This passed node is called context node. The solution of a path is the yielded sequence of the last step. If one step is not successful, it yields an empty sequence and no further steps are performed and the path has no solution. See evaluation for details.</p> <p></p>"},{"location":"language/grammar.html#composite-steps","title":"Composite Steps","text":"<p>A composite step is solely a basic step or its filtering or subscription (if it represents an array): </p> <p></p>"},{"location":"language/grammar.html#filter-subscript","title":"Filter &amp; Subscript","text":"<p>By means of a filter sequences of objects can be restricted to sub-sequences that have to fulfil the stated expression :</p> <p></p> <p>Subscripts are reserved for arrays and the stated expression must evaluate to a number :</p> <p></p> <p>!TODO array first class</p> <p>!TODO bool test</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, or the context node itself: </p> <p></p>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p>Step function calls take expressions as arguments and the context node and yield sequences of objects: </p> <p></p> <p>They are prominently used for extending apath, see Step Functions for details.</p>"},{"location":"language/grammar.html#properties","title":"Properties","text":"<p>Property values of an object can be selected by an identifier or regex. The identifier must not be an reserved word. If a regex is given, all properties conforming to it will be taken: </p> <p></p> <p>&lt;!-- </p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p>To retrieve all property values of an object or all items of an array the following construct can be used: </p> <p></p> <p>To access the context node, use the following: </p> <p></p>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":""},{"location":"language/grammar.html#composite-expressions","title":"Composite Expressions","text":"<p>Expressions can be sequenced, delimited by comma. In this case its value is the value of the last expression: </p> <p></p> <p>The conditional expression consists of the condition part, then-part, and optional else-part<sup>2</sup>: </p> <p></p>"},{"location":"language/grammar.html#basic-expressions","title":"Basic Expressions","text":"<p>Basic expressions follows the usual logical and relational expression syntax of programming languages . apath reuses javascript syntax. The following elements are directly derived from the js-PEG-grammar.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"language/grammar.html#compact-ebnf-grammar","title":"Compact EBNF Grammar","text":"<p>Main EBNF rules in PEG (Parsing Expression Grammars) style. </p> <pre><code>Start =\n     Expression? __ EOF\n//-\n//------------------------ Composite Steps ------------------------\n//-\nPath =\n    CompositeStep ('.' CompositeStep)*\nCompositeStep =\n    Filter / Subscript / BasicStep\nFilter =\n    BasicStep '?' '(' Expression ')'\nSubscript =\n    BasicStep '[' Expression ']'\n//-\n//- ------------------------ Basic Steps ------------------------\n//-\nBasicStep = \n    StepFunctionCall / Property / Children \n    / '(' Expression ')' \n    / Self\nProperty =\n    Identifier\n    / RegularExpressionLiteral\nChildren =\n    '*'\nSelf =\n    ('self' / '_')\nStepFunctionCall =\n    Identifier '(' ArgumentList? ')'\nArgumentList =\n    Conditional (',' Conditional)*\n//-\n//------------------------ Expressions ------------------------\n//-\nExpression = SequencedExpression\nSequencedExpression =\n    Conditional (',' Conditional)*\nConditional =\n    'if' '(' Expression ')' Expression (('else')? Expression)?\n    / LogicalORExpression\nLogicalORExpression\n  = LogicalANDExpression\n    ('or' LogicalANDExpression)*\nLogicalANDExpression\n  = EqualityExpression\n    ('and' EqualityExpression)*\nEqualityExpression\n  = RelationalExpression\n    (EqualityOperator RelationalExpression)*\nEqualityOperator\n  = \"==\"\n  / \"!=\"\nRelationalExpression\n  = UnaryExpression\n    (RelationalOperator UnaryExpression)*\nRelationalOperator\n  = \"&lt;=\"\n  / \"&gt;=\"\n  / \"&lt;\"\n  / \"&gt;\"\nUnaryExpression\n  = PrimaryExpression\n  / UnaryOperator UnaryExpression \nUnaryOperator\n  = \n  \"not\"\nPrimaryExpression\n  = Literal\n  / Path\n</code></pre> <ol> <li> <p>non-Terminals are hyper-linked if defined here.\u00a0\u21a9</p> </li> <li> <p>Omitting the else keyword enables compact case chains and is comparable with conditionals in other functional languages. For instance, a chain could be written as <pre><code>if (A) B\nif (C) D\n...\nE\n</code></pre> For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/intro.html","title":"Intro","text":"<p>For now language description consists of</p> <ul> <li>a cheat sheet</li> <li>language elements by means of railroad diagrams</li> <li>semantics in form of context node processing tables (fortcoming)</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/step-functions.html","title":"Step Functions","text":""},{"location":"language/step-functions.html#user-defined-functions","title":"User Defined Functions","text":""},{"location":"language/step-functions.html#apath","title":"apath","text":"<p>...forthcoming...</p>"},{"location":"language/step-functions.html#javascript","title":"Javascript","text":""},{"location":"language/step-functions.html#standard-functions","title":"Standard Functions","text":"<p>...forthcoming...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/tutorial.html","title":"...forthcoming...","text":""},{"location":"language/variables.html","title":"Variables","text":"<p>...forthcoming...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"workbench/workbench.html","title":"Workbench","text":"<p>The workbench can be used to interactively explore apath language constructs. As seen below it consists of a control panel and four (resizable and draggable) widgets for</p> <ul> <li>json input</li> <li>(optional) js step function</li> <li>apath expression</li> <li>result of evaluation</li> </ul> <p>respectively.</p> workbench main window <p>Initially the first example of the <code>walk-through</code> is shown (see control panel). All cheat-sheet examples are taken from the <code>walk-through</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>walk-through</code>: step by step examples through essential language elements</li> <li><code>widgets</code><ul> <li><code>dark</code> mode</li> <li><code>fit</code> widgets in main window</li> <li><code>live fit</code></li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>live eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup>.</li> </ul> </li> <li><code>info</code>: opens the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet part corresponds to the selected <code>walk-through</code>-example</li> </ul> <ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the path <code>a[0]</code> yields no solution. If <code>strict failure</code> is enabled the error message <code>ApathError: error during evaluation (cause: ExecutionError: object must be an array (context: subscription))</code> is returned (future versions of apath will return the location). This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}