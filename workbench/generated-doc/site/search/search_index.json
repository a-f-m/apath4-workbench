{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#_1","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. Variables enable the reuse of existing values, whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax are well-defined, using Parsing Expression Grammars and Algebraic Data Types, respectively. Implementation is based on compilation (for now to JavaScript) instead of interpretation (of the abstract syntax tree), that ensures performant execution and can be adapted to support other target languages. Specification and development are in progress, so every feature described here will be implemented step by step.<sup>2</sup></p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, it is planned to offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p>"},{"location":"home/intro.html#remark-on-formalism","title":"Remark on Formalism","text":"<p>For now, due to the fact that apath is foremost targeted at practitioners, an formalization is pending. Nevertheless, a formalization with denotational semantics will be given in future that is primarily oriented towards</p> <ul> <li>Philip Wadler (2000). A Formal Semantics of Patterns in XSLT and XPath. Markup Languages 2(2): 183-202</li> </ul> <p>enhanced by predicate logic based formalization of constraints. For the time being, a semi-formal description can be found in the evaluation section.</p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> <li> <p>A first version of apath - with similar syntax - was created in April 2016, targeted at java (with AST interpretation) and used in real-life projects. Considerations for improvement and extensions led to the present version.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"Evaluation","text":""},{"location":"language/eval.html#evaluation","title":"Evaluation","text":""},{"location":"language/eval.html#boolean-evaluation","title":"Boolean Evaluation","text":"<p>Almost any expression can be used as an argument for boolean constructs such as filters, conditionals or logical operators. Due to the fact that an expression evaluates to a [[#sequence]] of nodes, it is necessary to precisely define its evaluation to an boolean value.</p> <p>The boolean function [[test]] maps sequence \\(S\\) to a boolean value:</p> <ol> <li>)\u00a0\u00a0 if \\(S\\) is a sequence with more than one element, the boolean value is true</li> <li>)\u00a0\u00a0 if \\(S\\) is a [[#singleton]] value \\(e\\) and<ol> <li>)\u00a0\u00a0 \\(e\\) of type boolean, then the boolean value is \\(e\\) </li> <li>)\u00a0\u00a0 otherwise the boolean value is true</li> </ol> </li> <li>)\u00a0\u00a0 if \\(S\\) is an [[#empty sequence]], the boolean value is false</li> </ol>"},{"location":"language/eval.html#processing-table","title":"Processing Table","text":"<p>The evaluations of essential expressions whose evaluations could not be immediately apparent, are the focus of this section.</p> <p>The semantic function eval maps an expression \\(E\\) and a context node \\(o\\), which is initially the input node, to a [[#sequence]] of nodes, and is partially defined in the following table.</p> language element expression pattern \\(E\\) eval(\\(E\\), \\(o\\))(evaluation of \\(E\\) with context node \\(o\\))eval(\\(F\\)) =  eval(\\(F\\), \\(o\\)) for arbitrary \\(F\\) remark self <code>_</code> return \\(o\\) scope expression <code>X</code>, <code>Y</code> eval(<code>X</code>)return eval(<code>Y</code>) <code>X</code>,<code>Y</code>,<code>Z</code> \\(=\\) ((<code>X</code>,<code>Y</code>),<code>Z</code>) path <code>X</code>.<code>Y</code> let \\(R\\) be the empty sequencefor every \\(x\\) in eval(<code>X</code>) do\\(\\;\\;\\;\\)for every \\(y\\) in eval(<code>Y</code>, \\(x\\)) do\\(\\;\\;\\;\\;\\;\\;\\)include \\(y\\) in \\(R\\)return \\(R\\) <code>X</code>.<code>Y</code>.<code>Z</code> \\(=\\) ((<code>X</code>.<code>Y</code>).<code>Z</code>) conditional if (<code>B</code>) <code>X</code> <code>Y</code> if (test(eval(<code>B</code>))) then return eval(<code>X</code>)else return eval(<code>Y</code>) filter <code>X</code>?(<code>Y</code>) let \\(R\\) be the empty sequence for every \\(x\\) in eval(<code>X</code>) do\\(\\;\\;\\;\\)if (test(eval(<code>Y</code>, \\(x\\)))) then include \\(x\\) in \\(R\\)return \\(R\\) construction (object) { <code>p</code> : <code>X</code>, ... } return { <code>p</code> : eval(<code>X</code>), ... } <code>p</code> is an identifier or string ... dynamic property { prop(<code>X</code>) : <code>Y</code>, ... } return { eval(<code>X</code>) : eval(<code>Y</code>), ... } <code>X</code> must evaluate to a string ... embedding { <code>X</code>, ... } return { properties(eval(<code>X</code>)), ... } <code>X</code> must evaluate to a singleton containing an object. properties(\\(x\\)) 'embeds' the properties of \\(x\\) into the enclosing object <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/grammar.html","title":"Grammar-based Description","text":""},{"location":"language/grammar.html#grammar-based-description","title":"Grammar-based Description","text":"<p>apath is an expression language, so the start rule is Expression. The grammar will be described top-down<sup>1</sup>. Icon  references the related cheat-sheet part and icon (1) shows an example popup. Furthermore, icon [eval:processing-table] shows the semantics of the language element. See also basic definitions.</p> <ol> <li> <p>property  [wb:basic:property]</p> <p>input:</p> <pre><code>[exa-input:basic:property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":"<p>Every (sub-)expression in apath is evaluated to a sequence of nodes and the result of the entire expression is the composition of the evaluations of the individual sub-expressions. We say that an evaluation has no solution if the corresponding sequence is empty.</p> <p> <p></p> <p>The grammar starts with consecutive expressions, delimited by comma. In this case, its value is the value of the last one. It is mostly used for side effects, e.g., logging or variable assignment.(1) [eval:eval-scope expression]</p> <ol> <li> <p>scope expression  [wb:basic:scope expression]</p> <p>input:</p> <pre><code>[exa-input:basic:scope expression]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:scope expression]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:scope expression]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#step-functions","title":"Step Functions","text":"<p> <p></p> <p>Step functions support the reuse of functionality and the building of custom language elements. Step functions are divided in functions written in apath itself (described here) or written in javascript.</p> <p>A function definition is introduced with the <code>func</code> keyword, followed by a parameter list and the expression it should return. The context of the specified expression is the one that was valid when the function was called. Parameters are referenced in the same way as variables.(1) Frequently used constructions can be reused(2), and complex functions can be defined with local variables and access to global variables.(3)</p> <ol> <li> <p>reusable expressions  [wb:basic:reusable expressions]</p> <p>input:</p> <pre><code>[exa-input:basic:reusable expressions]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:reusable expressions]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:reusable expressions]\n</code></pre> </li> <li> <p>... construction  [wb:basic:... construction]</p> <p>input:</p> <pre><code>[exa-input:basic:... construction]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... construction]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... construction]\n</code></pre> </li> <li> <p>recursion  [wb:basic:recursion]</p> <p>input:</p> <pre><code>[exa-input:basic:recursion]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:recursion]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:recursion]\n</code></pre> </li> </ol> Note / Body <p>For simple functions, the expression can be specified directly in the function body. For more complex ones, we recommend using parentheses (<code>ScopeExpression</code> in basic step).</p>"},{"location":"language/grammar.html#variables","title":"Variables","text":"<p>Variables enables the reuse of values. They are declared implicitly the first time they are assigned. Their scope is the <code>ScopeExpression</code> in which they were declared.(1) As well as being used to store simple values, they can be used to memorize nodes that are referenced (with the <code>$</code> symbol) in subsequent paths.(2) Finally, entire sequences can also be saved, enabling you to realize joins.(3)</p> <ol> <li> <p>variable assignment  [wb:basic:variable assignment]</p> <p>input:</p> <pre><code>[exa-input:basic:variable assignment]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:variable assignment]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:variable assignment]\n</code></pre> </li> <li> <p>... memoizing nodes  [wb:basic:... memoizing nodes]</p> <p>input:</p> <pre><code>[exa-input:basic:... memoizing nodes]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... memoizing nodes]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... memoizing nodes]\n</code></pre> </li> <li> <p>... joins  [wb:basic:... joins]</p> <p>input:</p> <pre><code>[exa-input:basic:... joins]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... joins]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... joins]\n</code></pre> </li> </ol> Note / Design <p>The dollar symbol <code>$</code> is only used for referencing variables. Within the assignment expression or in the parameters of a function declaration, it is omitted for reasons of better readability, thus following the design of some scripting languages (e.g., shell scripting). This is because it is clearly decidable in the places of the assignment statement, whereas in referencing it could collide with a property name, for instance.</p>"},{"location":"language/grammar.html#ordinary-expressions","title":"Ordinary Expressions","text":"<p> <p></p> <p>The conditional consists of the condition-part, then-part, and optional alternative (else-part).(1) [eval:eval-conditional]</p> <ol> <li> <p>conditional  [wb:basic:conditional]</p> <p>input:</p> <pre><code>[exa-input:basic:conditional]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:conditional]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:conditional]\n</code></pre> </li> </ol> Tip / else-part <p>As in some other functional languages (e.g. clojure and scheme), conditionals are without the else keyword. For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.</p> <p>Basic elements, starting from <code>LogicalORExpression</code>, follow the usual logical and relational syntax of programming languages. apath mostly reuses javascript syntax, adopted from the javascript-PEG-grammar with slight changes.</p> <p>The keywords <code>and</code>/<code>or</code>/<code>not</code> (instead of <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) are used and equality/relational expressions (<code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>) are defined as usual, see compact grammar for details. Also, as usual, the atomic parts are primary expressions, and they now contain paths:</p> <p></p>"},{"location":"language/grammar.html#paths-steps","title":"Paths &amp; Steps","text":"<p>Paths consist of 'dot'-separated steps. Every step yields a sequence of nodes that are passed one by one to the subsequent step. This passed node is called [[context node]]. The solution of a path is the yielded sequence of the last step. If one step yields an empty sequence, no further steps are performed, and the solution of the whole path is the empty sequence. [eval:eval-property]</p> <p>A step is a filter, a subscription, or solely a basic step (if none of the optional branches are chosen).</p>"},{"location":"language/grammar.html#filter","title":"Filter","text":"<p>By means of a filter, the sequence retrieved by <code>Subscript</code> can be restricted to a subsequence of nodes. For every node in the original sequence, the filter expression is evaluated, and the result is passed to the test function (see test). If the test yields true, then the node is contained in the sub-sequence.(1) [eval:eval-filter (predicate)]</p> <ol> <li> <p>filter (predicate)  [wb:basic:filter (predicate)]</p> <p>input:</p> <pre><code>[exa-input:basic:filter (predicate)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:filter (predicate)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:filter (predicate)]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#subscript","title":"Subscript","text":"<p>Subscripts are reserved for arrays, and the index expression must evaluate to a number.(1)</p> <ol> <li> <p>subscript  [wb:basic:subscript]</p> <p>input:</p> <pre><code>[exa-input:basic:subscript]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:subscript]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:subscript]\n</code></pre> </li> </ol> Note / nested arrays <p>List of subscriptions are not directly supported. Nested array subscripts can be performed with <code>(...[i])[j]</code>.</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, the context node itself, or a variable reference. Furthermore, objects and arrays can be created. </p>"},{"location":"language/grammar.html#selection","title":"Selection","text":""},{"location":"language/grammar.html#properties","title":"Properties","text":"<p>Property values of an object can be selected by an identifier that must not be a reserved word.(1) If the property name is not a regular identifier (e.g. <code>#1</code>), a so-called name literal can be used.(2) If a regex is given, all properties with names conforming to it will be taken.(3)</p> <ol> <li> <p>property  [wb:basic:property]</p> <p>input:</p> <pre><code>[exa-input:basic:property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property]\n</code></pre> </li> <li> <p>property literal  [wb:basic:property literal]</p> <p>input:</p> <pre><code>[exa-input:basic:property literal]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property literal]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property literal]\n</code></pre> </li> <li> <p>property regex  [wb:basic:property regex]</p> <p>input:</p> <pre><code>[exa-input:basic:property regex]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property regex]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property regex]\n</code></pre> </li> </ol> <p>Dynamic property names can be realized with the help of the <code>prop</code> keyword. In this case, the evaluation of the argument must be a string.(1)</p> <ol> <li> <p>dynamic property  [wb:basic:dynamic property]</p> <p>input:</p> <pre><code>[exa-input:basic:dynamic property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:dynamic property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:dynamic property]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p> <p></p> <p>Step function calls can take arguments and yield a sequence defined by an apath function or javascript. Whenever they are invoked, the current context node is passed and used as usual within the body of the function. </p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p>To retrieve all property values of an object or all elements of an array, the children construct can be used.(1) To access the context node, use the following: (2)</p> <ol> <li> <p>children (array)  [wb:basic:children (array)]</p> <p>input:</p> <pre><code>[exa-input:basic:children (array)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:children (array)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:children (array)]\n</code></pre> </li> <li> <p>self  [wb:basic:self]</p> <p>input:</p> <pre><code>[exa-input:basic:self]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:self]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:self]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#construction","title":"Construction","text":"<p>The construction of objects and arrays conforms to JSON/javascript syntax with special enhancements.</p>"},{"location":"language/grammar.html#objects","title":"Objects","text":"<p> <p></p> <p> <p></p> <p>As usual, an object is built with a list of property assignments. The property value (right-hand side of an assignment) must be a singleton or empty. If it is empty, no assignment is performed. If the value is <code>none</code> then the property will be undefined.(1) [eval:eval-construction (object)]</p> <ol> <li> <p>construction (object)  [wb:basic:construction (object)]</p> <p>input:</p> <pre><code>[exa-input:basic:construction (object)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:construction (object)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:construction (object)]\n</code></pre> </li> </ol> Note / property value <p>If the sequence has more than one element, the value is not automatically an array as in other path languages, instead an error is thrown. If array construction is intended, the right-hand side can use the array constructor <code>[...]</code>.</p> <p>The property name can be at least an identifier or string -- we adopt the relaxed definition from javascript instead of JSON. </p> <p>If a property name shall be dynamically created, the <code>prop</code> keyword has to be used. In this case, the evaluation of the argument must be empty or a string. If empty, no assignment is performed, otherwise the string is used as the property name.(1) [eval:eval-... dynamic property] </p> <ol> <li> <p>... dynamic property  [wb:basic:... dynamic property]</p> <p>input:</p> <pre><code>[exa-input:basic:... dynamic property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... dynamic property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... dynamic property]\n</code></pre> </li> </ol> <p>So-called embeddings can be realized by omitting the property name. In this case, the value of the expression can be a sequence with more than one element. The properties of every node in this sequence, that has to be an object, are embedded in the constructed object, possibly overwriting previous properties.(1) [eval:eval-... embedding] </p> <ol> <li> <p>... embedding  [wb:basic:... embedding]</p> <p>input:</p> <pre><code>[exa-input:basic:... embedding]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... embedding]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... embedding]\n</code></pre> </li> </ol> Tip / object embeddings <p>By this an extension or modification of objects can be easily done, e. g., the expression pattern <code>{_, ...}</code> extends or modifies the context node (<code>'_'</code>) by subsequent assignments.</p>"},{"location":"language/grammar.html#arrays","title":"Arrays","text":"<p>The array constructor takes a list of values as consecutive array elements.(1) If one value is not a singleton, all its elements will be embedded.(2)</p> <ol> <li> <p>construction (array)  [wb:basic:construction (array)]</p> <p>input:</p> <pre><code>[exa-input:basic:construction (array)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:construction (array)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:construction (array)]\n</code></pre> </li> <li> <p>... sequences  [wb:basic:... sequences]</p> <p>input:</p> <pre><code>[exa-input:basic:... sequences]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... sequences]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... sequences]\n</code></pre> </li> </ol>"},{"location":"language/guide.html","title":"Guide","text":""},{"location":"language/guide.html#guide","title":"Guide","text":"<p>Based on a running example (1), the language elements are introduced according to their intended use. The json example describes an flat owner with his personal data and the flat inventory. The inventory consists of items purchased on a specific day.</p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol>"},{"location":"language/guide.html#selection-restriction","title":"Selection &amp; Restriction","text":"<pre><code>[exa-apath:guide:properties] __br__ [grammar-ra:main-rule-Property] __ __ [wb-ra:guide:properties]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>selects the name and the (non-identifier) property for the postal code with the result <code>[exa-result:guide:properties]</code>.<sup>1</sup></p> <pre><code>[exa-apath:guide:multiple properties] __br__ [grammar-ra:main-rule-Property] __ __ [wb-ra:guide:multiple properties]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>selects all properties with names matching a regular expression: <code>[exa-result:guide:multiple properties]</code>. <sup>2</sup></p> <pre><code>[exa-apath:guide:array items]   and   [exa-apath:guide:property values] __br__ [grammar-ra:main-rule-Children] __ __ [wb-ra:guide:array items]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>selects all array items and property values and results in <code>[exa-result:guide:array items]</code> and <code>[exa-result:guide:property values]</code>, respectively.</p> <pre><code>[exa-apath:guide:filter]  [grammar-ra:main-rule-Filter] __ __ [wb-ra:guide:filter]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>selects inventory items restricted to dates and an item category and calculates their total prices <code>[exa-result:guide:filter]</code>.</p> <p></p> <pre><code>[exa-apath:guide:regex match] [grammar-ra:main-rule-VariableAssignment] __ __ [wb-ra:guide:regex match]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>selects all items purchased in any October and calculates their total prices The output contains the date inherited from the inventory property. For this purpose, the inventory date is assigned to a variable (<code>d = date</code>) and used later (<code>$d</code>) to produce the output</p> <pre><code>[exa-result:guide:regex match]\n</code></pre> <p>The following example make use of the object returned by the <code>match</code> function.</p> <pre><code>[exa-apath:guide:regex groups] __ __ [wb-ra:guide:regex groups]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>The first line yields the object <code>{\"groups\": [\"Berlin, Germany\",\"Berlin\",\"Germany\"]}</code> that contains the regex groups from which the result <code>[exa-result:guide:regex groups]</code> is built.</p>"},{"location":"language/guide.html#construction-transformation","title":"Construction &amp; Transformation","text":"<p>A construction is a superset of json, allowing, for example, unquoted property names. If the context node is used - on top level equivalent to the input - we can speak of a transformation. For instance, the following expression</p> <pre><code>[exa-apath:guide:object construction] [grammar-ra:main-rule-Construction] __ __ [wb-ra:guide:object construction]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>yields <code>[exa-result:guide:object construction]</code> as the result.</p> <p></p> <pre><code>[exa-apath:guide:object sequence construction] [grammar-ra:main-rule-Construction] __ __ [wb-ra:guide:object sequence construction]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>constructs json objects as the result instead of strings (see previous example):</p> <pre><code>[exa-result:guide:object sequence construction]\n</code></pre> <p>In some applications it can happen that property names are not fixed and contain information that is otherwise given as a value. Furthermore, transformations are based on embedding input objects into the output:</p> <pre><code>[exa-apath:guide:dynamic name / embedding] [grammar-ra:main-rule-PropertyAssignment] __ __ [wb-ra:guide:dynamic name / embedding]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>transforms the running example into an object that has the top property name stemming from a property value, using the expression <code>prop(name)</code>, where <code>name</code> is the flat owner property containing its name. Furthermore, the <code>flatOwner</code> is embedded (<code>_</code>), the <code>location</code> modified, and some properties are removed (via keyword <code>none</code>):</p> <pre><code>[exa-result:guide:dynamic name / embedding]\n</code></pre> <p>The expression</p> <pre><code>[exa-apath:guide:classical merge] [grammar-ra:main-rule-PropertyAssignment] __ __ [wb-ra:guide:classical merge]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>performs the classical merge of multiple objects and has output </p> <pre><code>[exa-result:guide:classical merge]\n</code></pre> <p>A conditional embedding</p> <pre><code>[exa-apath:guide:conditional embedding] __br__ [grammar-ra:main-rule-PropertyAssignment] __ __ [wb-ra:guide:conditional embedding]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>has output <code>[exa-result:guide:conditional embedding]</code>.</p> <p>Conditionals plays an important role, not only in the form of filters, introduced earlier. The following example places a condition within a filter. Furthermore, the embedding of sequences in arrays is used. This is also called list comprehension in other functional languages. </p> <pre><code>[exa-apath:guide:nested conditional] [grammar-ra:main-rule-ArrayConstruction] __ __ [wb-ra:guide:nested conditional]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>stores the car in a variable for later use, and then builds the array by iterating over the inventory items and filtering them according to the quantity and the car. The filter is dynamically evaluated via the variable <code>heavyCar</code>. It yields output</p> <pre><code>[exa-result:guide:nested conditional]\n</code></pre> <p>Last, but not least, variables can also store sequences. In the following, two sequences are assigned to variables. Afterwards, a 'join' is performed on the names of the elements, and again embedded in an array.</p> <pre><code>[exa-apath:guide:join] [grammar-ra:main-rule-ArrayConstruction] __ __ [wb-ra:guide:join]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <pre><code>[exa-result:guide:join]\n</code></pre>"},{"location":"language/guide.html#step-functions","title":"Step Functions","text":"<p>The following simple step function <code>selectByDate</code> implements the filter from a previous example. Its context node is that of the call and its parameters are referenced with <code>$</code>, like variables.</p> <pre><code>[exa-apath:guide:simple function] [grammar-ra:main-rule-StepFunctionDefinition] __ __ [wb-ra:guide:simple function]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>Constructions can also be reused with the help of functions. The example given below modifies the previous one by outsourcing the construction part into the function <code>itemTotal</code>.</p> <pre><code>[exa-apath:guide:... construction] [grammar-ra:main-rule-StepFunctionDefinition] __ __ [wb-ra:guide:... construction]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>Note that in this particular case, the function body of <code>itemTotal</code> would not have to be enclosed in parentheses. However, this is advisable for complex functions.</p>"},{"location":"language/guide.html#javascript","title":"Javascript","text":"<p>Step functions in the host language (e.g., javascript) are used to realize functionality that is not available in apath itself. They have to follow a certain form, which is described in section Step Functions). </p> <pre><code>function formatCurrency(ctx_node, locales, currency) {\n  if (typeof ctx_node !== 'number') return undefined\n  return new Intl.NumberFormat(locales, { style: 'currency', currency })\n      .format(ctx_node)\n}\n</code></pre> <p>For instance, the previous function formats the context node, that have to be a number, according to <code>locales</code> and <code>currency</code>.</p> <pre><code>[exa-apath:guide:simple js step func] [grammar-ra:main-rule-StepFunctionCall] __ __ [wb-ra:guide:simple js step func]\n</code></pre> <p> (1) </p> <ol> <li>running example <pre><code>{\n  \"flatOwner\": {\n    \"name\": \"Miller\",\n    \"age\": 28,\n    \"location\": \"Berlin, Germany\",\n    \"#post-code\": 12205,\n    \"mobility\": {\n      \"driverLic\": true,\n      \"car\": \"transporter\"\n    },\n    \"favorites\": [ \"Coen\", \"Dylan\", \"Nietzsche\" ]\n  },\n  \"inventory\": [\n    {\n      \"date\": \"2023-10-05\",\n      \"items\": [\n        {\n          \"category\": \"furniture\",\n          \"name\": \"chair\",\n          \"price\": 50.00,\n          \"quantity\": 3\n        }\n      ]\n    },\n    {\n      \"date\": \"2024-10-01\",\n      \"items\": [\n        {\n          \"category\": \"electronic\",\n          \"name\": \"pc\",\n          \"price\": 1800.78,\n          \"quantity\": 1\n        },\n        {\n          \"category\": \"furniture\",\n          \"name\": \"table\",\n          \"price\": 100.10,\n          \"quantity\": 1\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> <p>The expression above makes use of it for the prices and yields the following result.</p> <pre><code>[exa-result:guide:simple js step func]\n</code></pre> <p>The parameters and return values of javascript Step functions can vary depending on the application (see cheat-sheet for more examples).</p> <ol> <li> <p>here '+' is the concatenation of strings.\u00a0\u21a9</p> </li> <li> <p>Multiple results are delimited by comma in the example output.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/intro.html","title":"Intro","text":""},{"location":"language/intro.html#_1","title":"Intro","text":"<p>For now, language description consists of</p> <ul> <li>a cheat sheet</li> <li>a guide</li> <li>language elements by means of railroad diagrams</li> <li>programmatic use of the javascript API</li> </ul> <p>Throughout the documentation, icon  references the related cheat-sheet parts,  related grammar elements,  the (semi-formal) semantics, and [wb:basic:property] the workbench.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/preliminaries.html","title":"Preliminaries","text":""},{"location":"language/preliminaries.html#preliminaries","title":"Preliminaries","text":"<p>In the following, we provide basic definitions used throughout the documentation, that are intended to aid understanding of the language elements.<sup>1</sup></p> <ul> <li>A string, number, boolean, or null is called [[atomic node]] (e. g. <code>1</code>, <code>'hello'</code>, <code>true</code>), an object or array is called [[structured node]] (e. g. <code>{a:1}</code>, <code>[1,2]</code>).</li> <li>A [[node]] is either an atomic or structured node.</li> <li>A [[sequence]] (of nodes) is an ordered collection of zero or more nodes. </li> <li>A sequence consisting of exactly one node is called a [[singleton]]. A node is identical to a singleton that contains that node.</li> <li>A sequence with zero nodes is called an [[empty sequence]].</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>We partly align to the xpath terminology.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/programatic.html","title":"Programmatic Use","text":""},{"location":"language/programatic.html#programmatic-use","title":"Programmatic Use","text":"<p>For now, the workbench site contains two bundles (generated by rollup):</p> <ul> <li>apath-lib-es.js for ES-compliant use and</li> <li>apath-lib-cjs.js for CommonJs-compliant use</li> </ul> <p>The following program exemplifies the usage of the API.</p> <pre><code>import { Apath } from './apath-lib-es.js'\n\n// a step func\nfunction f(ctx_node) {\n    return ctx_node + 1\n}\n\nconst apath = new Apath()\n\n// adding the step func\napath.step_func(f)\n\n// get the evaluator\nconst evaluator = apath.transpile('a.b.f()')\n\n// evaluate - 'results' is an iterator over found solutions\nconst results = evaluator.evaluate_json('{ \"a\": { \"b\": 1 } }')\n// with an object: ... evaluator.evaluate({ a: { b: 1 } })\n\n// iterate results\nfor (const result of results) console.log(result) // --&gt; 2\n\n// only the first result (more performant due to bypassing the iterator)\nconsole.log(evaluator.evaluate_first({ a: { b: 1 } })) // --&gt; 2\n</code></pre>"},{"location":"language/roadmap.html","title":"News & Roadmap","text":""},{"location":"language/roadmap.html#_1","title":"News & Roadmap","text":""},{"location":"language/roadmap.html#news","title":"News","text":"feature / construct / doc kind remark id cheat-sheet / grammar / workbench / section basic benchmark new starting basic benchmark for a simple expression R8 see Performance debugger new debugging expressions and breakpoints in the workbench R8 see Debugging (animated png's) apath step functions new reusable, parametrizable expressions via functions R8 dynamic property as a step new expression value used as the property name R7 guide new doc section: guide with running example R6 see guide programmatic use new doc section with API use R6 see programmatic use (semi-formal) semantics new doc section with processing table R6 see evaluation variables new variable declaration in scope expressions R5 match values new step function regex match for values R4 workbench store/restore new (re-)storing widgets locally R3 see workbench property literal changed resolved ambiguity for string literals in paths and expressions (<code>`...`</code>) R2 arithmetic new + - * / % - operators R1"},{"location":"language/roadmap.html#roadmap","title":"Roadmap","text":"<p>The following constructs/functionality are planned (not ordered by priority).</p> <ul> <li> workbench-integrated debugger</li> <li> variables</li> <li> (recursive) apath step functions</li> <li> rhs paths in assignments</li> <li> (composite) step enhancement<ul> <li> object-split</li> <li> regex over values</li> <li> operator to process sequences (sort, reduce)</li> <li> <code>[...]</code> for sequences</li> </ul> </li> <li> expressions<ul> <li> arithmetic </li> <li> some, every, union, implies</li> </ul> </li> <li> pattern matching</li> <li> logical constraints</li> <li> arrays as sequences</li> <li> ...</li> </ul>"},{"location":"language/step-functions.html","title":"Javascript Step Functions","text":""},{"location":"language/step-functions.html#javascript-step-functions","title":"Javascript Step Functions","text":"<p>Functions (the current host language) that enable functionality (so far) not expressable with apath, and the invocation of other services. They have to conform to the following form: </p> <pre><code>function &lt;func-id&gt;(ctx_node, arg1, ... , argN) {\n    // ... process context node 'ctx_node' and arguments\n    // ... possibly check an argument with 'apart.isApathIterable(argI)'\n    // ... create return value r that is an \n    // *apath-js-iterable*, *undefined* or other javascript value \n    return r\n}\n</code></pre> <p>where the first parameter <code>ctx_node</code> is the context node passed from path evaluation. An argument <code>argI</code> is either a [[#node]] or an apath-js-iterable that represents [sequences][[#sequence]].</p> <p>The return value <code>r</code> must be either a [[#node]], an apath-js-iterable, or undefined.</p> <p>\\(x\\) is [[apath-js-iterable]] if</p> <ul> <li>\\(x\\) is neither null, undefined, a string, or an array, and</li> <li>\\(x\\) is javascript-iterable (see Iteration protocols)</li> </ul> <p>To check wether an argument <code>argI</code> is apath-js-iterable, the runtime function <code>isApathIterable</code> can be used. [sheet:e-with sequences as parameters]</p> <p>The return value undefined indicates that no solution exists. In this case, at the path evaluation component, no further steps are performed, and the path has no solution [sheet:e-simple step function]. It is semantically equivalent to returning an [[#empty sequence]].</p>"},{"location":"language/variables.html","title":"Variables","text":""},{"location":"language/variables.html#variables","title":"Variables","text":"<p>Variables enables the reuse of values.  </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"performance/performance-1.html","title":"Performance","text":""},{"location":"performance/performance-1.html#_1","title":"Performance","text":""},{"location":"performance/performance-1.html#techniques","title":"Techniques","text":"<p>Of course, a complex selection and transformation language will always result in additional evaluation time in comparison to writing raw code in the host language. Our target is, at least, to reach an evaluation performance factor of \\(\\leq 5\\) (in relation to raw code).<sup>1</sup> In general, performance is enhanced by</p> <ul> <li>taking the compilation approach to avoid AST interpretation</li> <li>not wrapping all evaluation nodes as sequences, instead passing through single objects </li> <li>not materializing sequences (as arrays), instead only use of iterators  </li> <li>inlining expressions to a great extent </li> </ul>"},{"location":"performance/performance-1.html#benchmarks","title":"Benchmarks","text":""},{"location":"performance/performance-1.html#basic","title":"Basic","text":"<p>The following benchmark was performed with library <code>benchmark</code> (nodejs). The input object was <code>{ a: { i: 1, b: { c: 99 } } }</code> and the expression <code>a.b.c</code>. Note that top wrapping<sup>2</sup> was deactivated for apath, i.e. only the pure evaluation of the compiled expression was performed. The main reasons for the performance ratio of ~1.2 are runtime checks regarding the property names.</p> <pre><code>apath: 83,452,522 ops/sec (72 runs sampled)\nraw: 96,531,790 ops/sec (78 runs sampled)\n------\nmin Ratio: 1.244\nmax Ratio: 1.186\nRatio: 1.214\n</code></pre> <ol> <li> <p>This correlates with the typical range of 1.5 to 5 comparing functional and imperative languages like Haskell resp. C++. Basic operations can even achieve a ratio of ~1.2 .\u00a0\u21a9</p> </li> <li> <p>Deactivated top wrapping means that the first solution is taken regardless of whether it is an iterator or a simple object.\u00a0\u21a9</p> </li> </ol>"},{"location":"workbench/workbench.html","title":"Workbench","text":""},{"location":"workbench/workbench.html#_1","title":"Workbench","text":""},{"location":"workbench/workbench.html#main-window","title":"Main Window","text":"<p>The workbench (see  ) can be used to interactively explore apath language constructs. As seen below, it consists of a control panel and four (resizable and draggable) widgets for</p> <ul> <li>json input</li> <li>(optional) javascript step function</li> <li>apath expression</li> <li>result of the evaluation</li> </ul> workbench main window <p>Initially, the first example of the choosen topic is shown (see control panel). All cheat-sheet examples are taken from the topic <code>basic</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>examples</code>: step by step examples<ul> <li>categorized by topic (e. g. <code>basic</code>)</li> <li>example per topic (e. g. <code>property</code>)</li> </ul> </li> <li><code>widgets</code><ul> <li><code>open/close</code>: stores content of the widgets locally (control panel is not stored)</li> <li><code>save</code>: restores the widgets</li> <li><code>dark</code> mode for the widgets</li> <li><code>auto-fit</code> fitting widgets into the main window</li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>auto-eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup></li> <li><code>debug...</code>: opens the debugger</li> </ul> </li> <li><code>info</code>: opens the documentation (<code>doc</code>), the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet parts correspond to the selected <code>basic</code> example</li> </ul>"},{"location":"workbench/workbench.html#debugging","title":"Debugging","text":"<p>The workbench debugger makes it possible to follow the evaluation of an expression step by step. In contrast to conventional debuggers (e.g. for imperative languages), current steps are not defined by a line/column, but by the range of an entire expression.</p>"},{"location":"workbench/workbench.html#start-step-animated-png","title":"Start &amp; Step (animated png)","text":""},{"location":"workbench/workbench.html#breakpoints-animated-png","title":"Breakpoints (animated png)","text":"<ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the property selection <code>aa</code> yields no solution. If <code>strict failure</code> is enabled an error message is returned. This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}