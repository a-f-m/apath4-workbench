{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"a.html","title":"a...","text":""},{"location":"a.html#a1","title":"a1...","text":""},{"location":"b.html","title":"b...","text":""},{"location":"b.html#b1","title":"b1...","text":""},{"location":"c.html","title":"c...","text":""},{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. </p> <p>Moreover, variables enable reuse of existing values whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax is well-defined, using Parsing Expression Grammars and Abstract Data Types, respectively. Implementation follows the concept of transpilation (for now to JavaScript) that ensures performant execution and can be adapted to support other target languages.</p> <p>Specification and development is in progress, so every feature described here will be implemented step by step.</p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, apath will offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"...forthcoming...","text":""},{"location":"language/grammar.html","title":"Description by Grammar","text":"<p>apath is an expression language, so the start rule is of coarse Expression. For instance, <code>person.age == 18</code> checks equality of a value of a path with a literal value. Because a path with steps is the most used and central construct, the grammar here will start on this level. The grammar will be described top-down<sup>1</sup>.</p> <p>Icon  references the related cheat-sheet part.</p>"},{"location":"language/grammar.html#paths","title":"Paths","text":"<p> CompositeStep \".\" CompositeStep Path <p></p> <p>A path is a 'dot'-separated sequence of composite steps. Every step yields a sequence of nodes that are passed one by one to the subsequent step. This passed node is called context node. The solution of a path is the yielded sequence of the last step. If one step is not successful, it yields an empty sequence and no further steps are performed and the path has no solution. See evaluation for details.</p>"},{"location":"language/grammar.html#composite-steps","title":"Composite Steps","text":"<p> BasicStep \"?\" \"(\" Expression \")\" Filter BasicStep \"[\" Expression \"]\" Subscript StepFunctionCall Property Children \"(\" Expression \")\" Self Construction Modification BasicStep CompositeStep <p></p> <p>A composite step is solely a basic step or its filtering or subscription (if it represents an array). </p>"},{"location":"language/grammar.html#filter-subscript","title":"Filter &amp; Subscript","text":"<p> BasicStep \"?\" \"(\" Expression \")\" Filter <p></p> <p>By means of a filter sequences of objects can be restricted to sub-sequences of objects that have to fulfil the stated expression. </p> <p> BasicStep \"[\" Expression \"]\" Subscript <p></p> <p>Subscripts are reserved for arrays and the stated expression must evaluate to a number. </p> <p>!TODO array first class</p> <p>!TODO bool test</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p> Identifier \"(\" ArgumentList \")\" StepFunctionCall Identifier StringLiteral RegularExpressionLiteral Property \"*\" Children \"(\" SequencedExpression Expression \")\" \"self\" \"_\" Self ObjectLiteral ArrayLiteral Construction \"=\" Construction Modification BasicStep <p></p> <p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, or the context node itself. </p>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p> Identifier \"(\" ArgumentList \")\" StepFunctionCall <p></p> <p> Conditional \",\" Conditional ArgumentList <p></p> <p>Step function calls take expressions as arguments and the context node and yield sequences of objects. </p> <p>They are prominently used for extending apath, see Step Functions for details.</p>"},{"location":"language/grammar.html#properties","title":"Properties","text":"<p> ! ReservedWord IdentifierName Identifier \"\\\"\" DoubleStringCharacter \"\\\"\" \"'\" SingleStringCharacter \"'\" StringLiteral \"/\" RegularExpressionBody \"/\" RegularExpressionLiteral Property <p></p> <p>Property values of an object can be selected by an identifier or regex. The identifier must not be an reserved word. If a regex is given, all properties conforming to it will be taken. </p> <p> \"self\" \"_\" \"and\" \"or\" \"not\" \"if\" Keyword \"null\" NullLiteral \"true\" \"false\" BooleanLiteral ReservedWord <p></p> <p>!TODO string lit expr ambiguity</p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p> \"*\" Children <p></p> <p>To retrieve all property values of an object or all items of an array the <code>children</code> construct can be used. </p> <p>To access the context node, use the following: </p> <p> \"self\" \"_\" Self <p></p>"},{"location":"language/grammar.html#construction","title":"Construction","text":"<p> \"{\" PropertyAssignment \",\" PropertyAssignment PropertyAssignmentList \"}\" ObjectLiteral \"[\" Conditional \",\" Conditional ElementList \"]\" ArrayLiteral Construction <p></p> <p> PropertyName \":\" Conditional PropertyAssignment <p></p> <p> Identifier StringLiteral \"(\" Expression \")\" PropertyName <p></p>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":""},{"location":"language/grammar.html#composite-expressions","title":"Composite Expressions","text":"<p> Conditional \",\" Conditional SequencedExpression Expression <p></p> <p>Expressions can be sequenced, delimited by comma. In this case its value is the value of the last expression. </p> <p> \"if\" \"(\" Expression \")\" Expression Expression LogicalORExpression Conditional <p></p> <p>The conditional expression consists of the condition part, then-part, and optional alternative<sup>2</sup>. </p> <p>!TODO priority</p>"},{"location":"language/grammar.html#basic-expressions","title":"Basic Expressions","text":"<p>Basic expressions follows the usual logical and relational expression syntax of programming languages . apath reuses javascript syntax. The following elements are directly derived from the js-PEG-grammar.</p> <p> LogicalANDExpression \"or\" LogicalANDExpression LogicalORExpression <p> EqualityExpression \"and\" EqualityExpression LogicalANDExpression <p> RelationalExpression EqualityOperator RelationalExpression EqualityExpression <p> \"==\" \"!=\" EqualityOperator <p> UnaryExpression RelationalOperator UnaryExpression RelationalExpression <p> \"&lt;=\" \"&gt;=\" \"&lt;\" \"&gt;\" RelationalOperator <p> PrimaryExpression UnaryOperator UnaryExpression UnaryExpression <p> \"not\" UnaryOperator <p> \"/\" RegularExpressionBody \"/\" RegularExpressionLiteral <p> BooleanLiteral NumericLiteral StringLiteral Literal CompositeStep \".\" CompositeStep Path PrimaryExpression <p></p>"},{"location":"language/grammar.html#compact-ebnf-grammar","title":"Compact EBNF Grammar","text":"<p>Main EBNF rules in PEG (Parsing Expression Grammars) style. </p> <pre><code>//-\n//------------------------ Composite Steps ------------------------\n//-\nPath =\n    CompositeStep ('.' CompositeStep)*\nCompositeStep =\n    Filter / Subscript / BasicStep\nFilter =\n    BasicStep '?' '(' Expression ')'\nSubscript =\n    BasicStep '[' Expression ']'\n//-\n//- ------------------------ Basic Steps ------------------------\n//-\nBasicStep = \n    StepFunctionCall / Property / Children \n    / '(' Expression ')' \n    / Self\n    / Construction\n    / Modification\nProperty =\n    Identifier\n    / StringLiteral\n    / RegularExpressionLiteral\nChildren =\n    '*'\nSelf =\n    ('self' / '_')\nStepFunctionCall =\n    Identifier '(' ArgumentList? ')'\nArgumentList =\n    Conditional (',' Conditional)*\n//-\n//- ------------------------ Basic Steps / Construction &amp; Modification ------------------------\n//-\nConstruction =\n    ObjectLiteral\n    / ArrayLiteral\nObjectLiteral\n  = \"{\" PropertyAssignmentList? \"}\" \nPropertyAssignmentList\n  = PropertyAssignment (\",\" PropertyAssignment)* \nPropertyAssignment\n  = (PropertyName \":\")? Conditional \nPropertyName\n  = Identifier\n  / StringLiteral\n  / '(' Expression ')'\nArrayLiteral \n  = '[' ElementList? ']'\nElementList =\n    Conditional (',' Conditional)*\nModification =\n    '=' Construction\n//-\n//------------------------ Expressions ------------------------\n//-\nExpression = SequencedExpression\nSequencedExpression =\n    Conditional (',' Conditional)*\nConditional =\n    'if' '(' Expression ')' Expression Expression?\n    / LogicalORExpression\nLogicalORExpression\n  = LogicalANDExpression\n    ('or' LogicalANDExpression)*\nLogicalANDExpression\n  = EqualityExpression\n    ('and' EqualityExpression)*\nEqualityExpression\n  = RelationalExpression\n    (EqualityOperator RelationalExpression)*\nEqualityOperator\n  = \"==\"\n  / \"!=\"\nRelationalExpression\n  = UnaryExpression\n    (RelationalOperator UnaryExpression)*\nRelationalOperator\n  = \"&lt;=\"\n  / \"&gt;=\"\n  / \"&lt;\"\n  / \"&gt;\"\nUnaryExpression\n  = PrimaryExpression\n  / UnaryOperator UnaryExpression \nUnaryOperator\n  = \n  \"not\"\nPrimaryExpression\n  = Literal\n  / Path\n</code></pre> <ol> <li> <p>non-Terminals are hyper-linked if defined here.\u00a0\u21a9</p> </li> <li> <p>As in some other functional languages conditionals are without the else keyword. For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/intro.html","title":"Intro","text":"<p>For now language description consists of</p> <ul> <li>a cheat sheet</li> <li>language elements by means of railroad diagrams</li> <li>semantics in form of context node processing tables (fortcoming)</li> </ul> <p>Throughout the documentation, icon  references the related cheat-sheet part and icon  grammar elements. </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/step-functions.html","title":"Step Functions","text":"<p>Step functions support reuse of functionality and the building of custom language elements. Especially the latter one is essential for building domain specific languages. </p> <p>Step functions are divided in</p> <ul> <li>apath functions that enables reuse of (parametrizable) expressions</li> <li>javascript functions (the current host language) that enables functionality (so far) not expressable with apath, and the invocation of other services.</li> </ul>"},{"location":"language/step-functions.html#apath-functions","title":"apath functions","text":"<p>...forthcoming...</p>"},{"location":"language/step-functions.html#javascript","title":"Javascript","text":"<p>The following template shows a step function <code>func-id</code>: </p> <pre><code>function &lt;func-id&gt;(ctx_node, arg1, ... , argN) {\n    // ... process context node 'ctx_node' and arguments\n    // ... create return value r that is an \n    // *apath-iterable*, *undefined* or *object*\n    return r\n}\n</code></pre> <p>where</p> <ol> <li>the first parameter <code>ctx_node</code> is the context node passed from path evaluation. <code>ctx_node</code> and the arguments are arbitrary js objects.</li> <li>the return value must be<ol> <li>apath-iterable</li> <li>undefined</li> <li>any other object not (a) or (b).</li> </ol> </li> <li>x is apath-iterable iff<ol> <li>x is neither null, undefined, a string, or an array, and</li> <li>x is js-iterable (see Iteration protocols)</li> </ol> </li> </ol> <p>A return value of type apath-iterable (2.a, 3) represent sequences that are consumed by the path evaluation component where their elements are passed to the subsequent step one by one. </p> <p>The return value undefined indicates that no solution exists. In this case, at the path evaluation component, no further steps are performed and the path has no solution . It is semantically equivalent to returning an empty sequence.</p> <p>All other return values (2.c) are handled as one-element-sequences of the returned object.<sup>1</sup></p> <ol> <li> <p>Not to enforce one-element-sequences in this case avoids unnecessary wrapping of objects, especially when js library functions are used within return-expressions. Note that arrays are also objects.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/tutorial.html","title":"...forthcoming...","text":""},{"location":"language/variables.html","title":"Variables","text":"<p>...forthcoming...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"performance/performance-1.html","title":"Techniques","text":"<p>Of coarse, a complex selection and transformation language will ever result in additional evaluation time in contrast to writing raw code in the host language. Our target is, at least, to reach nearly the same performance for very basic expressions.<sup>1</sup> In general, performance is enhanced by</p> <ul> <li>taking the transpilation approach to avoid AST interpretation</li> <li>not wrapping all evaluation nodes as sequences, instead passing through single objects </li> <li>inlining expressions to a great extent </li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>For instance, first tests with the path <code>a.b.c</code> yield a performance overhead of 1.22 compared with pure js.\u00a0\u21a9</p> </li> </ol>"},{"location":"workbench/workbench.html","title":"Workbench","text":"<p>The workbench can be used to interactively explore apath language constructs. As seen below it consists of a control panel and four (resizable and draggable) widgets for</p> <ul> <li>json input</li> <li>(optional) js step function</li> <li>apath expression</li> <li>result of evaluation</li> </ul> <p>respectively.</p> workbench main window <p>Initially the first example of the <code>walk-through</code> is shown (see control panel). All cheat-sheet examples are taken from the <code>walk-through</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>walk-through</code>: step by step examples through essential language elements</li> <li><code>widgets</code><ul> <li><code>dark</code> mode</li> <li><code>fit</code> widgets in main window</li> <li><code>live fit</code></li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>live eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup>.</li> </ul> </li> <li><code>info</code>: opens the documentation (<code>doc</code>), the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet part corresponds to the selected <code>walk-through</code>-example</li> </ul> <ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the path <code>a[0]</code> yields no solution. If <code>strict failure</code> is enabled the error message <code>ApathError: error during evaluation (cause: ExecutionError: object must be an array (context: subscription))</code> is returned (future versions of apath will return the location). This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}