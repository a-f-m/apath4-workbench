var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"a.html","title":"a...","text":""},{"location":"a.html#a1","title":"a1...","text":""},{"location":"b.html","title":"b...","text":""},{"location":"b.html#b1","title":"b1...","text":""},{"location":"c.html","title":"c...","text":""},{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. Variables enable reuse of existing values whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax is well-defined, using Parsing Expression Grammars and Abstract Data Types, respectively. Implementation follows the concept of transpilation (for now to JavaScript) that ensures performant execution and can be adapted to support other target languages.</p> <p>Specification and development is in progress, so every feature described here will be implemented step by step. A first version of apath - with similar syntax - was created at April 2016, targeted at java (with AST interpretation) and used in real live projects. Considerations for improvement and extensions led to the present version. </p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, it is planned to offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p>"},{"location":"home/intro.html#remark-on-formalism","title":"Remark on Formalism","text":"<p>For now, due to the fact that apath is foremost targeted at practitioners, an explicit formalization is pending. Nevertheless, a formalization in form of denotational semantics will be given in future that is primarily oriented towards</p> <ul> <li>Philip Wadler (2000). A Formal Semantics of Patterns in XSLT and XPath. Markup Languages 2(2): 183-202</li> </ul> <p>enhanced by predicate logic based formalization of constraints.</p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"Evaluation","text":""},{"location":"language/eval.html#boolean-evaluation","title":"Boolean Evaluation","text":"<p>Almost any expression can be used as an argument for boolean constructs such as filters, conditionals or logical operators. Due to the fact that an expression evaluates to a sequence of nodes it is necessary to precisely define its evaluation to an boolean value.</p> <p>The boolean function [[test]] maps sequence \\(S\\) to a boolean value:</p> <ul> <li>if \\(S\\) is an [[#empty sequence]] the boolean value is false</li> <li>if \\(S\\) is a [[#singleton]] value \\(e\\) and<ul> <li>\\(e\\) of type boolean then the boolean value is \\(e\\) </li> <li>otherwise the boolean value is true</li> </ul> </li> <li>if \\(S\\) is a sequence with more than one element the boolean value is true</li> </ul> <p>!TODO rem on strings and null</p>"},{"location":"language/eval.html#processing-table","title":"Processing Table","text":"<p>...forthcoming...</p>"},{"location":"language/grammar.html","title":"Description by Grammar","text":"<p>apath is an expression language, so the start rule is of coarse Expression. For instance, <code>person.age == 18</code> checks equality of a value of a path with a literal value. Because a path with steps is the most used and central construct, the grammar here will start on this level. The grammar will be described top-down<sup>1</sup>.</p> <p>Icon [sheet:cheat-sheet-generated] references the related cheat-sheet part. See also basic definitions.</p>"},{"location":"language/grammar.html#paths","title":"Paths","text":"<p>[id:main-rule-Path]</p> <p>Paths consist of 'dot'-separated composite steps. Every step yields a [[#sequence]] of [nodes][[#node]] that are passed one by one to the subsequent step. This passed [[#node]] is called [[context node]]. The solution of a path is the yielded sequence of the last step. If one step yields an [[#empty sequence]], no further steps are performed and the solution of the whole path is the empty sequence. See evaluation for details.</p>"},{"location":"language/grammar.html#composite-steps","title":"Composite Steps","text":"<p>[id:main-rule-CompositeStep]</p> <p>A composite step is solely a basic step or its filtering or subscription (if it represents an array). [sheet:e-Composite Steps] </p>"},{"location":"language/grammar.html#filter-subscript","title":"Filter &amp; Subscript","text":"<p>[id:main-rule-Filter]</p> <p>By means of a filter, [sequences][[#sequence]], retrieved by the base step, can be restricted to sub-sequences of [nodes][[#node]] that fulfil the stated expression. [sheet:e-filter (predicate)] </p> <p>[id:main-rule-Subscript]</p> <p>Subscripts are reserved for arrays and the stated expression must evaluate to a number. [sheet:e-subscript]</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p>[id:main-rule-BasicStep]</p> <p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, or the context node itself. [sheet:e-Basic Steps] Furthermore, objects and arrays can be created. [sheet:e-Basic Steps / Construction]</p>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p>[id:main-rule-StepFunctionCall]</p> <p>Step function calls take expressions as arguments and yield [sequences][[#sequence]] defined by the function. [sheet:javascript-step-functions-user-defined] They are prominently used for extending apath, see Step Functions for details.</p>"},{"location":"language/grammar.html#properties","title":"Properties","text":"<p>[id:main-rule-Property]</p> <p>Property values of an object can be selected by an identifier that must not be an reserved word. If the property name is not a regular identifier (e.g. <code>#1</code>), a string literal can be used.  If a regex is given, all properties with names conforming to it will be taken. [sheet:e-property]</p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p>[id:main-rule-Children]</p> <p>To retrieve all property values of an object or all elements of an array the children construct can be used. [sheet:e-children (array)] To access the [[#context node]], use the following: [sheet:e-self]</p> <p>[id:main-rule-Self]</p>"},{"location":"language/grammar.html#construction","title":"Construction","text":"<p>[id:main-rule-Construction]</p> <p>Construction of objects and arrays conforms to JSON/js syntax with special enhancements. [sheet:e-Basic Steps / Construction]</p>"},{"location":"language/grammar.html#objects","title":"Objects","text":"<p>[id:main-rule-ObjectConstruction]</p> <p>[id:main-rule-PropertyAssignment]</p> <p>[id:main-rule-PropertyName]</p> <p>A usual, an object are build with a list of property assignments. The property value (right hand side of an assignment) is an expression whose value must be a [[#singleton]] or [empty][[#empty sequence]].<sup>2</sup> If it is empty no assignment is performed. The property name can be at least an identifier or string -- we adopt the relaxed definition from js instead of JSON. [sheet:e-construction (object)] </p> <p>If a property name shall be dynamically created, a parenthesized expression have to be used. In this case its evaluation must be a string. [sheet:e-... dynamic property] </p> <p>So-called embeddings can be realized by omitting the property name. In this case, the value of the expression can be a [[#sequence]] with more than one element. The properties of every [[#node]] in this sequence is embedded in the constructed object, possibly overwriting previous properties.<sup>3</sup> [sheet:e-... embedding]</p>"},{"location":"language/grammar.html#arrays","title":"Arrays","text":"<p>[id:main-rule-ArrayConstruction]</p> <p>The array constructor takes a list of expression values as consecutive array elements. [sheet:e-construction (array)] If one value is not a [[#singleton]] all its elements will be embedded. [sheet:e-... sequences]</p>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":""},{"location":"language/grammar.html#composite-expressions","title":"Composite Expressions","text":"<p>[id:main-rule-Expression]</p> <p>Expressions can be sequenced, delimited by comma. In this case its value is the value of the last expression. [sheet:e-Composite Expressions]</p> <p>[id:main-rule-ConditionalExpression]</p> <p>The conditional expression consists of the condition part, then-part, and optional alternative<sup>4</sup>. [sheet:e-conditional]</p>"},{"location":"language/grammar.html#basic-expressions","title":"Basic Expressions","text":"<p>Basic expressions follows the usual logical and relational expression syntax of programming languages [sheet:e-Comparison/Logical Expressions]. apath mostly reuses javascript syntax. The following elements are adopted from the js-PEG-grammar with slight changes.</p> <p>[id:main-rule-LogicalORExpression]</p> <p>[id:main-rule-LogicalANDExpression]</p> <p>[id:main-rule-EqualityExpression]</p> <p>[id:main-rule-EqualityOperator]</p> <p>[id:main-rule-RelationalExpression]</p> <p>[id:main-rule-RelationalOperator]</p> <p>[id:main-rule-UnaryExpression]</p> <p>[id:main-rule-UnaryOperator]</p> <p>[id:main-rule-RegularExpressionLiteral]</p> <p></p>"},{"location":"language/grammar.html#compact-ebnf-grammar","title":"Compact EBNF Grammar","text":"<p>Main EBNF rules in PEG (Parsing Expression Grammars) style. </p> <pre><code>//-\n//------------------------ Composite Steps ------------------------\n//-\nPath =\n    CompositeStep ('.' CompositeStep)*\nCompositeStep =\n    Filter / Subscript / BasicStep\nFilter =\n    BasicStep '?' '(' Expression ')'\nSubscript =\n    BasicStep '[' Expression ']'\n//-\n//- ------------------------ Basic Steps ------------------------\n//-\nBasicStep = \n    StepFunctionCall / Property / Children \n    / '(' Expression ')' \n    / Self\n    / Construction\nProperty =\n    Identifier\n    / StringLiteral\n    / RegularExpressionLiteral\nChildren =\n    '*'\nSelf =\n    ('self' / '_')\nStepFunctionCall =\n    Identifier '(' ArgumentList? ')'\nArgumentList =\n    ConditionalExpression (',' ConditionalExpression)*\n//-\n//- ------------------------ Basic Steps / Construction ------------------------\n//-\nConstruction =\n    ObjectConstruction\n    / ArrayConstruction\nObjectConstruction\n  = \"{\" PropertyAssignmentList? \"}\" \nPropertyAssignmentList\n  = PropertyAssignment (\",\" PropertyAssignment)* \nPropertyAssignment\n  = (PropertyName \":\")? ConditionalExpression \nPropertyName\n  = Identifier\n  / StringLiteral\n  / '(' Expression ')'\nArrayConstruction \n  = '[' ElementList? ']'\nElementList =\n    ConditionalExpression (',' ConditionalExpression)*\n//-\n//------------------------ Expressions ------------------------\n//-\nExpression = SequencedExpression\nSequencedExpression =\n    ConditionalExpression (',' ConditionalExpression)*\nConditionalExpression =\n    'if' '(' Expression ')' Expression Expression?\n    / LogicalORExpression\nLogicalORExpression\n  = LogicalANDExpression\n    ('or' LogicalANDExpression)*\nLogicalANDExpression\n  = EqualityExpression\n    ('and' EqualityExpression)*\nEqualityExpression\n  = RelationalExpression\n    (EqualityOperator RelationalExpression)*\nEqualityOperator\n  = \"==\"\n  / \"!=\"\nRelationalExpression\n  = UnaryExpression\n    (RelationalOperator UnaryExpression)*\nRelationalOperator\n  = \"&lt;=\"\n  / \"&gt;=\"\n  / \"&lt;\"\n  / \"&gt;\"\nUnaryExpression\n  = PrimaryExpression\n  / UnaryOperator UnaryExpression \nUnaryOperator\n  = \n  \"not\"\nPrimaryExpression\n  = Literal\n  / Path\n</code></pre> <ol> <li> <p>non-Terminals are hyper-linked if defined here.\u00a0\u21a9</p> </li> <li> <p>Other path languages allow sequences with more than one element, which are automatically resolved to an array. We omit this functionality for clarity. If this behavior is intended, the right hand side can simply use the array constructor <code>[...]</code>.\u00a0\u21a9</p> </li> <li> <p>By this an extension of objects can be easily done, e. g., the expression pattern <code>{_, ...}</code> extends the context node (<code>self</code>) by subsequent assignments. Rem.: Future versions of apath will support paths at the left hand side of assignments such that deep assignments can be easily defined.\u00a0\u21a9</p> </li> <li> <p>As in some other functional languages conditionals are without the else keyword. For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/guide.html","title":"...forthcoming...","text":""},{"location":"language/intro.html","title":"Intro","text":"<p>For now language description consists of</p> <ul> <li>preliminaries that define the basic terminology</li> <li>a cheat sheet</li> <li>a guide</li> <li>language elements by means of railroad diagrams</li> <li>an evaluation description in form of context node processing tables (fortcoming)</li> </ul> <p>Throughout the documentation,  references the related cheat-sheet parts and  related grammar elements.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/preliminaries.html","title":"Preliminaries","text":"<p>The the following we provide basic definitions, used throughout the documentation, which is intended to aid understanding of the language elements.<sup>1</sup></p> <ul> <li>A string, number, boolean, or null is called [[atomic node]] (e. g. <code>1</code>, <code>'hello'</code>, <code>true</code>), an object or array is called [[structured node]] (e. g. <code>{a:1}</code>, <code>[1,2]</code>).</li> <li>A [[node]] is either an atomic or structured node.</li> <li>A [[sequence]] (of nodes) is an ordered collection of zero or more nodes. </li> <li>A sequence consisting of exactly one node is called a [[singleton]]. A node is identical to a singleton that contains that node.</li> <li>A sequence with zero nodes is called an [[empty sequence]].</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>We partly align to the xpath terminology.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/roadmap.html","title":"Roadmap","text":"<ul> <li>variables</li> <li>apath step functions</li> <li>rhs paths in assignments</li> <li>(composite) step enhancement<ul> <li>object-split</li> <li>regex over values</li> <li>\u00b0-operator to process sequences (sort, reduce)</li> </ul> </li> <li>expressions<ul> <li>arithmetic </li> <li>some, every</li> </ul> </li> <li>pattern matching</li> <li>logical constraints</li> <li>...</li> </ul>"},{"location":"language/step-functions.html","title":"Step Functions","text":"<p>Step functions support reuse of functionality and the building of custom language elements. Especially the latter one is essential for building domain specific languages. [sheet:javascript-step-functions-user-defined]</p> <p>Step functions are divided in</p> <ul> <li>apath functions that enables (parametrizable) reuse of expressions</li> <li>javascript functions (the current host language) that enables functionality (so far) not expressable with apath, and the invocation of other services.</li> </ul>"},{"location":"language/step-functions.html#apath-functions","title":"apath functions","text":"<p>...forthcoming...</p>"},{"location":"language/step-functions.html#javascript","title":"Javascript","text":"<p>Step functions have to conform to the following form: </p> <pre><code>function &lt;func-id&gt;(ctx_node, arg1, ... , argN) {\n    // ... process context node 'ctx_node' and arguments\n    // ... possibly check an argument with 'apart.isApathIterable(argI)'\n    // ... create return value r that is an \n    // *apath-js-iterable*, *undefined* or other javascript value\n    return r\n}\n</code></pre> <p>where</p> <p>The first parameter <code>ctx_node</code> is the context node passed from path evaluation. An argument <code>argI</code> is either a [[#node]] or an apath-js-iterable that represents [sequences][[#sequence]].</p> <p>The return value <code>r</code> must be either a [[#node]], an apath-js-iterable, or undefined.</p> <p>\\(x\\) is [[apath-js-iterable]] if</p> <ul> <li>\\(x\\) is neither null, undefined, a string, or an array, and</li> <li>\\(x\\) is javascript-iterable (see Iteration protocols)</li> </ul> <p>To check wether an argument <code>argI</code> is apath-js-iterable, the runtime function <code>isApathIterable</code> can be used. [sheet:e-with sequences as parameters]</p> <p>The return value undefined indicates that no solution exists. In this case, at the path evaluation component, no further steps are performed and the path has no solution [sheet:e-simple step function]. It is semantically equivalent to returning an [[#empty sequence]].</p>"},{"location":"language/variables.html","title":"Variables","text":"<p>...forthcoming...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"performance/performance-1.html","title":"Performance","text":""},{"location":"performance/performance-1.html#techniques","title":"Techniques","text":"<p>Of coarse, a complex selection and transformation language will ever result in additional evaluation time in contrast to writing raw code in the host language. Our target is, at least, to reach an evaluation performance factor of \\(\\leq 5\\) (in relation to raw code).<sup>1</sup> In general, performance is enhanced by</p> <ul> <li>taking the transpilation approach to avoid AST interpretation</li> <li>not wrapping all evaluation nodes as sequences, instead passing through single objects </li> <li>inlining expressions to a great extent </li> </ul>"},{"location":"performance/performance-1.html#benchmarks","title":"Benchmarks","text":"<p>... forthcoming ...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>For instance, first tests with simple paths like <code>a.b.c</code> yield a performance overhead of ~2.1 compared with pure js. This correlates with the typical range of 1.5 to 5 comparing functional and imperative languages like Haskell resp. C++.\u00a0\u21a9</p> </li> </ol>"},{"location":"workbench/workbench.html","title":"Workbench","text":""},{"location":"workbench/workbench.html#main-window","title":"Main Window","text":"<p>The workbench  can be used to interactively explore apath language constructs. As seen below it consists of a control panel and widgets for</p> <ul> <li>json input</li> <li>(optional) js step function</li> <li>apath expression</li> <li>result of evaluation</li> </ul> workbench main window <p>Initially the first example of the <code>walk-through</code> is shown (see control panel). All cheat-sheet examples are taken from the <code>walk-through</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>walk-through</code>: step by step examples through essential language elements</li> <li><code>widgets</code><ul> <li><code>dark</code> mode for the widgets</li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>live eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup>.</li> </ul> </li> <li><code>info</code>: opens the documentation (<code>doc</code>), the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet part corresponds to the selected <code>walk-through</code>-example</li> </ul> <ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the path <code>a[0]</code> yields no solution. If <code>strict failure</code> is enabled the error message <code>ApathError: error during evaluation (cause: ExecutionError: object must be an array (context: subscription))</code> is returned (future versions of apath will return the location). This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}