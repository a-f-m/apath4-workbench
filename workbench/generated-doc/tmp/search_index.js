var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. Variables enable the reuse of existing values, whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax are well-defined, using Parsing Expression Grammars and Algebraic Data Types, respectively. Implementation follows the concept of transpilation (for now to JavaScript), that ensures performant execution and can be adapted to support other target languages.</p> <p>Specification and development are in progress, so every feature described here will be implemented step by step. A first version of apath - with similar syntax - was created in April 2016, targeted at java (with AST interpretation) and used in real-live projects. Considerations for improvement and extensions led to the present version. </p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, it is planned to offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p>"},{"location":"home/intro.html#remark-on-formalism","title":"Remark on Formalism","text":"<p>For now, due to the fact that apath is foremost targeted at practitioners, an formalization is pending. Nevertheless, a formalization with denotational semantics will be given in future that is primarily oriented towards</p> <ul> <li>Philip Wadler (2000). A Formal Semantics of Patterns in XSLT and XPath. Markup Languages 2(2): 183-202</li> </ul> <p>enhanced by predicate logic based formalization of constraints.</p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"Evaluation","text":""},{"location":"language/eval.html#boolean-evaluation","title":"Boolean Evaluation","text":"<p>Almost any expression can be used as an argument for boolean constructs such as filters, conditionals or logical operators. Due to the fact that an expression evaluates to a sequence of nodes, it is necessary to precisely define its evaluation to an boolean value.</p> <p>The boolean function [[test]] maps sequence \\(S\\) to a boolean value:</p> <ol> <li>)\u00a0\u00a0 if \\(S\\) is a sequence with more than one element, the boolean value is true</li> <li>)\u00a0\u00a0 if \\(S\\) is a [[#singleton]] value \\(e\\) and<ol> <li>)\u00a0\u00a0 \\(e\\) of type boolean, then the boolean value is \\(e\\) </li> <li>)\u00a0\u00a0 otherwise the boolean value is true</li> </ol> </li> <li>)\u00a0\u00a0 if \\(S\\) is an [[#empty sequence]], the boolean value is false</li> </ol>"},{"location":"language/eval.html#processing-table","title":"Processing Table","text":"<p>...forthcoming...</p>"},{"location":"language/grammar.html","title":"Description by Grammar","text":"<p>apath is an expression language, so the start rule is Expression. The grammar will be described top-down<sup>1</sup>. Icon  references the related cheat-sheet part and icon (1) shows an example popup. See also basic definitions.</p> <ol> <li> <p>property  [wb:basic:property]</p> <p>input:</p> <pre><code>[exa-input:basic:property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":"<p>Every (sub-)expression in apath is evaluated to a sequence of nodes. The result of the entire apath expression is the composition of the evaluations of the individual sub-expressions. We say that an evaluation has no solution if the corresponding sequence is empty.</p> <p>Expressions can be sequenced, delimited by a comma. In this case, its value is the value of the last expression. It is mostly used for side effects, e.g., logging or variable declaration. All expressions are evaluated sequentially. (1) </p> <ol> <li> <p>sequenced  [wb:basic:sequenced]</p> <p>input:</p> <pre><code>[exa-input:basic:sequenced]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:sequenced]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:sequenced]\n</code></pre> </li> </ol> <p>The conditional expression consists of the condition-part, then-part, and optional alternative (else-part). (1) </p> <ol> <li> <p>conditional  [wb:basic:conditional]</p> <p>input:</p> <pre><code>[exa-input:basic:conditional]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:conditional]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:conditional]\n</code></pre> </li> </ol> Tip / else-part <p>As in some other functional languages (e.g. clojure and scheme), conditionals are without the else keyword. For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.</p> <p>Basic expressions, starting from <code>LogicalORExpression</code>, follow the usual logical and relational expression syntax of programming languages . apath mostly reuses javascript syntax, adopted from the javascript-PEG-grammar with slight changes.</p> <p>Logical expressions use keywords <code>and</code>/<code>or</code>/<code>not</code> (instead of <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) and equality/relational expressions (<code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>) are defined as usual, see compact grammar for details. Also, as usual, the atomic parts of an expression are primary expressions, and they now contain paths:</p> <p></p>"},{"location":"language/grammar.html#paths-steps","title":"Paths &amp; Steps","text":"<p>Paths consist of 'dot'-separated steps. Every step yields a sequence of nodes that are passed one by one to the subsequent step. This passed node is called [[context node]]. The solution of a path is the yielded sequence of the last step. If one step yields an empty sequence, no further steps are performed, and the solution of the whole path is the empty sequence. See evaluation for details.</p> <p>A step is a filter, a subscription, or solely a basic step (if none of the optional branches are chosen). </p>"},{"location":"language/grammar.html#filter","title":"Filter","text":"<p>By means of a filter, the sequence retrieved by the base step can be restricted to a subsequence of nodes. (1) For every node in the original sequence, the filter expression is evaluated, and the result is passed to the test function (see test). If the test is true, then the node is contained in the  sub-sequence.</p> <ol> <li> <p>filter (predicate)  [wb:basic:filter (predicate)]</p> <p>input:</p> <pre><code>[exa-input:basic:filter (predicate)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:filter (predicate)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:filter (predicate)]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#subscript","title":"Subscript","text":"<p>Subscripts are reserved for arrays, and the stated expression must evaluate to a number. (1)</p> <ol> <li> <p>subscript  [wb:basic:subscript]</p> <p>input:</p> <pre><code>[exa-input:basic:subscript]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:subscript]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:subscript]\n</code></pre> </li> </ol> Note / nested arrays <p>List of subscriptions are not directly supported. Nested array subscripts can be performed with <code>(...[i])[j]</code>.</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, or the context node itself.  Furthermore, objects and arrays can be created.  </p>"},{"location":"language/grammar.html#selection","title":"Selection","text":""},{"location":"language/grammar.html#properties","title":"Properties","text":"<p>Property values of an object can be selected by an identifier that must not be a reserved word. (1) If the property name is not a regular identifier (e.g. <code>#1</code>), a so-called name literal can be used. (2) If a regex is given, all properties with names conforming to it will be taken. (3)</p> <ol> <li> <p>property  [wb:basic:property]</p> <p>input:</p> <pre><code>[exa-input:basic:property]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property]\n</code></pre> </li> <li> <p>property literal  [wb:basic:property literal]</p> <p>input:</p> <pre><code>[exa-input:basic:property literal]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property literal]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property literal]\n</code></pre> </li> <li> <p>property regex  [wb:basic:property regex]</p> <p>input:</p> <pre><code>[exa-input:basic:property regex]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:property regex]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:property regex]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p> <p></p> <p>Step function calls take expressions as arguments and yield a sequence defined by the function.  They are prominently used for extending apath, see Step Functions for details.</p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p>To retrieve all property values of an object or all elements of an array, the children construct can be used. (1) To access the context node, use the following: (2)</p> <ol> <li> <p>children (array)  [wb:basic:children (array)]</p> <p>input:</p> <pre><code>[exa-input:basic:children (array)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:children (array)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:children (array)]\n</code></pre> </li> <li> <p>self  [wb:basic:self]</p> <p>input:</p> <pre><code>[exa-input:basic:self]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:self]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:self]\n</code></pre> </li> </ol>"},{"location":"language/grammar.html#construction","title":"Construction","text":"<p>The construction of objects and arrays conforms to JSON/javascript syntax with special enhancements. </p>"},{"location":"language/grammar.html#objects","title":"Objects","text":"<p> <p></p> <p> <p></p> <p>As usual, an object is built with a list of property assignments. The property value (right-hand side of an assignment) is an expression whose value must be a singleton or empty. (1) If it is empty, no assignment is performed.</p> <ol> <li> <p>construction (object)  [wb:basic:construction (object)]</p> <p>input:</p> <pre><code>[exa-input:basic:construction (object)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:construction (object)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:construction (object)]\n</code></pre> </li> </ol> Note / property value <p>If the sequence has more than one element, the value is not automatically an array as in other path languages, instead an error is thrown. If array construction is intended, the right-hand side can use the array constructor <code>[...]</code>.</p> <p>The property name can be at least an identifier or string -- we adopt the relaxed definition from javascript instead of JSON. If a property name shall be dynamically created, a parenthesized expression has to be used. In this case, its evaluation must be a string. (1)</p> <ol> <li> <p>... dynamic property name  [wb:basic:... dynamic property name]</p> <p>input:</p> <pre><code>[exa-input:basic:... dynamic property name]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... dynamic property name]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... dynamic property name]\n</code></pre> </li> </ol> <p>So-called embeddings can be realized by omitting the property name. In this case, the value of the expression can be a sequence with more than one element. The properties of every node in this sequence, that has to be an object, are embedded in the constructed object, possibly overwriting previous properties. (1)</p> <ol> <li> <p>... embedding  [wb:basic:... embedding]</p> <p>input:</p> <pre><code>[exa-input:basic:... embedding]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... embedding]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... embedding]\n</code></pre> </li> </ol> Tip / object embeddings <p>By this an extension or modification of objects can be easily done, e. g., the expression pattern <code>{_, ...}</code> extends or modifies the context node (<code>'_'</code>) by subsequent assignments.</p>"},{"location":"language/grammar.html#arrays","title":"Arrays","text":"<p>The array constructor takes a list of expression values as consecutive array elements. (1) If one value is not a singleton, all its elements will be embedded. (2)</p> <ol> <li> <p>construction (array)  [wb:basic:construction (array)]</p> <p>input:</p> <pre><code>[exa-input:basic:construction (array)]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:construction (array)]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:construction (array)]\n</code></pre> </li> <li> <p>... sequences  [wb:basic:... sequences]</p> <p>input:</p> <pre><code>[exa-input:basic:... sequences]\n</code></pre> <p>apath:</p> <pre><code>[exa-apath:basic:... sequences]\n</code></pre> <p>result:</p> <pre><code>[exa-result:basic:... sequences]\n</code></pre> </li> </ol>"},{"location":"language/guide.html","title":"...forthcoming...","text":""},{"location":"language/intro.html","title":"Intro","text":"<p>For now, language description consists of</p> <ul> <li>preliminaries that define the basic terminology</li> <li>a cheat sheet</li> <li>a guide</li> <li>language elements by means of railroad diagrams</li> <li>an evaluation description in the form of context node processing tables (fortcoming)</li> </ul> <p>Throughout the documentation,  references the related cheat-sheet parts and  related grammar elements.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/preliminaries.html","title":"Preliminaries","text":"<p>In the following, we provide basic definitions used throughout the documentation, that are intended to aid understanding of the language elements.<sup>1</sup></p> <ul> <li>A string, number, boolean, or null is called [[atomic node]] (e. g. <code>1</code>, <code>'hello'</code>, <code>true</code>), an object or array is called [[structured node]] (e. g. <code>{a:1}</code>, <code>[1,2]</code>).</li> <li>A [[node]] is either an atomic or structured node.</li> <li>A [[sequence]] (of nodes) is an ordered collection of zero or more nodes. </li> <li>A sequence consisting of exactly one node is called a [[singleton]]. A node is identical to a singleton that contains that node.</li> <li>A sequence with zero nodes is called an [[empty sequence]].</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>We partly align to the xpath terminology.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/roadmap.html","title":"News & Roadmap","text":""},{"location":"language/roadmap.html#news","title":"News","text":"feature / construct kind remark id grammar,workbench match values new step function regex match for values R4 workbench store/restore new (re-)storing widgets locally R3 see workbench property literal changed resolved ambiguity for string literals in paths and expressions (<code>`...`</code>) R2 arithmetic new + - * / % - operators R1"},{"location":"language/roadmap.html#roadmap","title":"Roadmap","text":"<p>The following constructs/functionality are planned (not ordered by priority).</p> <ul> <li>variables</li> <li>apath step functions</li> <li>rhs paths in assignments</li> <li>(composite) step enhancement<ul> <li>object-split</li> <li>(x) regex over values</li> <li>operator to process sequences (sort, reduce)</li> </ul> </li> <li>expressions<ul> <li>(x) arithmetic </li> <li>some, every, union</li> </ul> </li> <li>pattern matching</li> <li>logical constraints</li> <li>...</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/step-functions.html","title":"Step Functions","text":"<p>Step functions support the reuse of functionality and the building of custom language elements. Especially the latter one is essential for building domain specific languages. [sheet:javascript-step-functions-user-defined]</p> <p>Step functions are divided in</p> <ul> <li>apath functions that enable (parametrizable) reuse of expressions</li> <li>javascript functions (the current host language) that enable functionality (so far) not expressable with apath, and the invocation of other services.</li> </ul>"},{"location":"language/step-functions.html#apath-functions","title":"apath functions","text":"<p>...forthcoming...</p>"},{"location":"language/step-functions.html#javascript","title":"Javascript","text":"<p>Step functions have to conform to the following form: </p> <pre><code>function &lt;func-id&gt;(ctx_node, arg1, ... , argN) {\n    // ... process context node 'ctx_node' and arguments\n    // ... possibly check an argument with 'apart.isApathIterable(argI)'\n    // ... create return value r that is an \n    // *apath-js-iterable*, *undefined* or other javascript value \n    return r\n}\n</code></pre> <p>where the first parameter <code>ctx_node</code> is the context node passed from path evaluation. An argument <code>argI</code> is either a [[#node]] or an apath-js-iterable that represents [sequences][[#sequence]].</p> <p>The return value <code>r</code> must be either a [[#node]], an apath-js-iterable, or undefined.</p> <p>\\(x\\) is [[apath-js-iterable]] if</p> <ul> <li>\\(x\\) is neither null, undefined, a string, or an array, and</li> <li>\\(x\\) is javascript-iterable (see Iteration protocols)</li> </ul> <p>To check wether an argument <code>argI</code> is apath-js-iterable, the runtime function <code>isApathIterable</code> can be used. [sheet:e-with sequences as parameters]</p> <p>The return value undefined indicates that no solution exists. In this case, at the path evaluation component, no further steps are performed, and the path has no solution [sheet:e-simple step function]. It is semantically equivalent to returning an [[#empty sequence]].</p>"},{"location":"language/variables.html","title":"Variables","text":"<p>...forthcoming...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"performance/performance-1.html","title":"Performance","text":""},{"location":"performance/performance-1.html#techniques","title":"Techniques","text":"<p>Of course, a complex selection and transformation language will always result in additional evaluation time in contrast to writing raw code in the host language. Our target is, at least, to reach an evaluation performance factor of \\(\\leq 5\\) (in relation to raw code).<sup>1</sup> In general, performance is enhanced by</p> <ul> <li>taking the transpilation approach to avoid AST interpretation</li> <li>not wrapping all evaluation nodes as sequences, instead passing through single objects </li> <li>not materializing sequences (as arrays), instead only use of iterators  </li> <li>inlining expressions to a great extent </li> </ul>"},{"location":"performance/performance-1.html#benchmarks","title":"Benchmarks","text":"<p>... forthcoming ...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>For instance, first tests with simple paths like <code>a.b.c</code> yield a performance overhead of ~2.5 compared with pure javascript (first 'inlining' experiments even yield factor 1.3). This correlates with the typical range of 1.5 to 5 comparing functional and imperative languages like Haskell resp. C++.\u00a0\u21a9</p> </li> </ol>"},{"location":"workbench/workbench.html","title":"Workbench","text":""},{"location":"workbench/workbench.html#main-window","title":"Main Window","text":"<p>The workbench (see  ) can be used to interactively explore apath language constructs. As seen below, it consists of a control panel and four (resizable and draggable) widgets for</p> <ul> <li>json input</li> <li>(optional) javascript step function</li> <li>apath expression</li> <li>result of the evaluation</li> </ul> workbench main window <p>Initially, the first example of the choosen topic is shown (see control panel). All cheat-sheet examples are taken from the topic <code>basic</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>examples</code>: step by step examples<ul> <li>categorized by topic (e. g. <code>basic</code>)</li> <li>example per topic (e. g. <code>property</code>)</li> </ul> </li> <li><code>widgets</code><ul> <li><code>store</code>: stores content of the widgets locally (control panel is not stored)</li> <li><code>restore</code>: restores the widgets</li> <li><code>dark</code> mode for the widgets</li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>live eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup>.</li> </ul> </li> <li><code>info</code>: opens the documentation (<code>doc</code>), the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet parts correspond to the selected <code>basic</code> example</li> </ul> <ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the property selection <code>aa</code> yields no solution. If <code>strict failure</code> is enabled an error message is returned. This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}