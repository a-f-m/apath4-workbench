{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home/intro.html","title":"Home","text":""},{"location":"home/intro.html#preface","title":"Preface","text":"<p>apath<sup>1</sup> is a language for processing hierarchical structures (for now json). It follows the principles of xpath/xslt and aims at having one language for </p> <ul> <li>Selection</li> <li>Construction &amp; Transformation</li> <li>Constraints</li> </ul> <p>Simple selections as well as complex and re-usable expressions can be defined. Variables enable the reuse of existing values, whereas so-called step functions support reuse of expressions and the building of custom language elements. </p> <p>The concrete and abstract syntax are well-defined, using Parsing Expression Grammars and Algebraic Data Types, respectively. Implementation is based on compilation (for now to JavaScript) instead of interpretation (of the abstract syntax tree), that ensures performant execution and can be adapted to support other target languages.</p> <p>Specification and development are in progress, so every feature described here will be implemented step by step. A first version of apath - with similar syntax - was created in April 2016, targeted at java (with AST interpretation) and used in real-live projects. Considerations for improvement and extensions led to the present version. </p>"},{"location":"home/intro.html#remark-on-constraints","title":"Remark on Constraints","text":"<p>In addition to the functionality of a selection and transformation language, it is planned to offer language elements for logical constraints. </p> <p>Logical constraints will enable consistency checks for objects as well as rule definitions for derived values.  </p>"},{"location":"home/intro.html#remark-on-formalism","title":"Remark on Formalism","text":"<p>For now, due to the fact that apath is foremost targeted at practitioners, an formalization is pending. Nevertheless, a formalization with denotational semantics will be given in future that is primarily oriented towards</p> <ul> <li>Philip Wadler (2000). A Formal Semantics of Patterns in XSLT and XPath. Markup Languages 2(2): 183-202</li> </ul> <p>enhanced by predicate logic based formalization of constraints.</p> <ol> <li> <p>Although the name suggests a path language, it is designed for complex transformations oriented towards xslt and general term transformations as well as logical constraints.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/eval.html","title":"Evaluation","text":""},{"location":"language/eval.html#boolean-evaluation","title":"Boolean Evaluation","text":"<p>Almost any expression can be used as an argument for boolean constructs such as filters, conditionals or logical operators. Due to the fact that an expression evaluates to a [[#sequence]] of nodes, it is necessary to precisely define its evaluation to an boolean value.</p> <p>The boolean function [[test]] maps sequence \\(S\\) to a boolean value:</p> <ol> <li>)\u00a0\u00a0 if \\(S\\) is a sequence with more than one element, the boolean value is true</li> <li>)\u00a0\u00a0 if \\(S\\) is a [[#singleton]] value \\(e\\) and<ol> <li>)\u00a0\u00a0 \\(e\\) of type boolean, then the boolean value is \\(e\\) </li> <li>)\u00a0\u00a0 otherwise the boolean value is true</li> </ol> </li> <li>)\u00a0\u00a0 if \\(S\\) is an [[#empty sequence]], the boolean value is false</li> </ol>"},{"location":"language/eval.html#processing-table","title":"Processing Table","text":"<p>The evaluations of essential, compound expressions whose evaluations could not be immediately apparent, are the focus of this section.</p> <p>The semantic function eval maps an expression <code>X</code> and a context node \\(o\\), which is initially the input node, to a sequence of nodes, and is partially defined in the following table.</p> language element expression pattern evaluationcontext node: \\(o\\)shortcut!: eval(<code>X</code>) =  eval(<code>X</code>, \\(o\\)) remark self <code>_</code> return \\(o\\) scope expression <code>X</code>, <code>Y</code> eval(<code>X</code>)return eval(<code>Y</code>) <code>X</code>,<code>Y</code>,<code>Z</code> \\(=\\) ((<code>X</code>,<code>Y</code>),<code>Z</code>) conditional if (<code>B</code>) <code>X</code> <code>Y</code> if (test(eval(<code>B</code>))) then return eval(<code>X</code>)else return eval(<code>Y</code>) path <code>X</code>.<code>Y</code> let \\(R\\) be the empty sequencefor every \\(x\\) in eval(<code>X</code>) do\\(\\;\\;\\;\\)for every \\(y\\) in eval(<code>Y</code>, \\(x\\)) do\\(\\;\\;\\;\\;\\;\\;\\)include \\(y\\) in \\(R\\)return \\(R\\) <code>X</code>.<code>Y</code>.<code>Z</code> \\(=\\) ((<code>X</code>.<code>Y</code>).<code>Z</code>) filter <code>X</code>?(<code>Y</code>) let \\(R\\) be the empty sequence for every \\(x\\) in eval(<code>X</code>) do\\(\\;\\;\\;\\)if (test(eval(<code>Y</code>, \\(x\\)))) then include \\(x\\) in \\(R\\)return \\(R\\) construction (object) { <code>p</code> : <code>X</code>, ... } return { <code>p</code> : eval(<code>X</code>), ... } <code>p</code> is an identifier or string ... dynamic property name { (<code>X</code>) : <code>Y</code>, ... } return { eval(<code>X</code>) : eval(<code>Y</code>), ... } <code>X</code> must evaluate to a string ... embedding { <code>X</code>, ... } return { properties(eval(<code>X</code>)), ... } <code>X</code> must evaluate to an object. properties(\\(x\\)) 'embeds' the properties of \\(x\\) into the enclosing object <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/grammar.html","title":"Description by Grammar","text":"<p>apath is an expression language, so the start rule is Expression. The grammar will be described top-down<sup>1</sup>. Icon  references the related cheat-sheet part and icon (1) shows an example popup. Furthermore, icon [eval:processing-table] shows the semantics of the language element. See also basic definitions.</p> <ol> <li>[snippet:doc-exa-snippet-1:property]</li> </ol>"},{"location":"language/grammar.html#expressions","title":"Expressions","text":"<p>Every (sub-)expression in apath is evaluated to a sequence of nodes and the result of the entire expression is the composition of the evaluations of the individual sub-expressions. We say that an evaluation has no solution if the corresponding sequence is empty.</p> <p> <p></p> <p>The grammar starts with consecutive expressions, delimited by comma. In this case, its value is the value of the last one. It is mostly used for side effects, e.g., logging or variable assignment. (1) [eval:eval-scope expression]</p> <ol> <li>[snippet:doc-exa-snippet-1:scope expression]</li> </ol>"},{"location":"language/grammar.html#variables","title":"Variables","text":"<p>Variables enables the reuse of values. They are declared implicitly the first time they are assigned. Their scope is the <code>ScopeExpression</code> in which they were declared. (1) As well as being used to store simple values, they can be used to memorize nodes that are referenced (with the <code>$</code> symbol) in subsequent paths. (2) Finally, entire sequences can also be saved, enabling you to realize joins. (3)</p> <ol> <li>[snippet:doc-exa-snippet-1:variable assignment]</li> <li>[snippet:doc-exa-snippet-1:... memoizing nodes]</li> <li>[snippet:doc-exa-snippet-1:... joins]</li> </ol> Note / Design <p>The dollar symbol <code>$</code> is only used throughout for referencing variables. Within the assignment expression or in the parameters of a function declaration (forthcoming), it is omitted for reasons of better readability, thus following the design of some scripting languages (e.g. shell scripting). This is because it is clearly decidable in the places of the assignment statement, whereas in referencing it could collide with a property name, for instance.</p>"},{"location":"language/grammar.html#ordinary-expressions","title":"Ordinary Expressions","text":"<p> <p></p> <p>The conditional consists of the condition-part, then-part, and optional alternative (else-part). (1) [eval:eval-conditional]</p> <ol> <li>[snippet:doc-exa-snippet-1:conditional]</li> </ol> Tip / else-part <p>As in some other functional languages (e.g. clojure and scheme), conditionals are without the else keyword. For complex parts, parsing unambiguousness, and better readability you can use parenthesized expressions, e. g., <code>if (A) (a, b) (c + 1)</code>. Only very simple ones could skip them.</p> <p>Basic elements, starting from <code>LogicalORExpression</code>, follow the usual logical and relational syntax of programming languages . apath mostly reuses javascript syntax, adopted from the javascript-PEG-grammar with slight changes.</p> <p>The keywords <code>and</code>/<code>or</code>/<code>not</code> (instead of <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) are used and equality/relational expressions (<code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>) are defined as usual, see compact grammar for details. Also, as usual, the atomic parts are primary expressions, and they now contain paths:</p> <p></p>"},{"location":"language/grammar.html#paths-steps","title":"Paths &amp; Steps","text":"<p>Paths consist of 'dot'-separated steps. Every step yields a sequence of nodes that are passed one by one to the subsequent step. This passed node is called [[context node]]. The solution of a path is the yielded sequence of the last step. If one step yields an empty sequence, no further steps are performed, and the solution of the whole path is the empty sequence.  [eval:eval-property]</p> <p>A step is a filter, a subscription, or solely a basic step (if none of the optional branches are chosen). </p>"},{"location":"language/grammar.html#filter","title":"Filter","text":"<p>By means of a filter, the sequence retrieved by <code>Subscript</code> can be restricted to a subsequence of nodes. For every node in the original sequence, the filter expression is evaluated, and the result is passed to the test function (see test). If the test yields true, then the node is contained in the sub-sequence. (1) [eval:eval-filter (predicate)]</p> <ol> <li>[snippet:doc-exa-snippet-1:filter (predicate)]</li> </ol>"},{"location":"language/grammar.html#subscript","title":"Subscript","text":"<p>Subscripts are reserved for arrays, and the index expression must evaluate to a number. (1)</p> <ol> <li>[snippet:doc-exa-snippet-1:subscript]</li> </ol> Note / nested arrays <p>List of subscriptions are not directly supported. Nested array subscripts can be performed with <code>(...[i])[j]</code>.</p>"},{"location":"language/grammar.html#basic-steps","title":"Basic Steps","text":"<p>A basic step is a step function call, a property value selection, all children, a parenthesized expression, the context node itself, or a variable reference.  Furthermore, objects and arrays can be created.  </p>"},{"location":"language/grammar.html#selection","title":"Selection","text":""},{"location":"language/grammar.html#properties","title":"Properties","text":"<p>Property values of an object can be selected by an identifier that must not be a reserved word. (1) If the property name is not a regular identifier (e.g. <code>#1</code>), a so-called name literal can be used. (2) If a regex is given, all properties with names conforming to it will be taken. (3)</p> <ol> <li>[snippet:doc-exa-snippet-1:property]</li> <li>[snippet:doc-exa-snippet-1:property literal]</li> <li>[snippet:doc-exa-snippet-1:property regex]</li> </ol>"},{"location":"language/grammar.html#step-function-call","title":"Step Function Call","text":"<p> <p></p> <p>Step function calls can take arguments and yield a sequence defined by the function.  They are prominently used for extending apath, see Step Functions for details.</p>"},{"location":"language/grammar.html#children-self","title":"Children &amp; Self","text":"<p>To retrieve all property values of an object or all elements of an array, the children construct can be used. (1) To access the context node, use the following: (2)</p> <ol> <li>[snippet:doc-exa-snippet-1:children (array)]</li> <li>[snippet:doc-exa-snippet-1:self]</li> </ol>"},{"location":"language/grammar.html#construction","title":"Construction","text":"<p>The construction of objects and arrays conforms to JSON/javascript syntax with special enhancements. </p>"},{"location":"language/grammar.html#objects","title":"Objects","text":"<p> <p></p> <p> <p></p> <p>As usual, an object is built with a list of property assignments. The property value (right-hand side of an assignment) must be a singleton or empty. If it is empty, no assignment is performed. If the value is <code>none</code> then the property will be undefined (1) [eval:eval-construction (object)]</p> <ol> <li>[snippet:doc-exa-snippet-1:construction (object)]</li> </ol> Note / property value <p>If the sequence has more than one element, the value is not automatically an array as in other path languages, instead an error is thrown. If array construction is intended, the right-hand side can use the array constructor <code>[...]</code>.</p> <p>The property name can be at least an identifier or string -- we adopt the relaxed definition from javascript instead of JSON. If a property name shall be dynamically created, a parenthesized expression has to be used. In this case, its evaluation must be a string. (1) [eval:eval-... dynamic property name] </p> <ol> <li>[snippet:doc-exa-snippet-1:... dynamic property name]</li> </ol> <p>So-called embeddings can be realized by omitting the property name. In this case, the value of the expression can be a sequence with more than one element. The properties of every node in this sequence, that has to be an object, are embedded in the constructed object, possibly overwriting previous properties. (1) [eval:eval-... embedding] </p> <ol> <li>[snippet:doc-exa-snippet-1:... embedding]</li> </ol> Tip / object embeddings <p>By this an extension or modification of objects can be easily done, e. g., the expression pattern <code>{_, ...}</code> extends or modifies the context node (<code>'_'</code>) by subsequent assignments.</p>"},{"location":"language/grammar.html#arrays","title":"Arrays","text":"<p>The array constructor takes a list of values as consecutive array elements. (1) If one value is not a singleton, all its elements will be embedded. (2)</p> <ol> <li>[snippet:doc-exa-snippet-1:construction (array)]</li> <li>[snippet:doc-exa-snippet-1:... sequences]</li> </ol>"},{"location":"language/guide.html","title":"Guide","text":""},{"location":"language/guide.html#guide","title":"Guide","text":"<p>Based on the running example, the language elements are introduced according to their intended use. The json example describes an flat owner with his personal data and the flat inventory. The inventory consists of items purchased on a specific day. (1)</p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol>"},{"location":"language/guide.html#selection-restriction","title":"Selection &amp; Restriction","text":"<pre><code>[exa-apath:guide:properties] __br__ [wb-ra:guide:properties]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>selects the name and the (non-identifier) property for the postal code with the result <code>[exa-result:guide:properties]</code>.<sup>1</sup></p> <pre><code>[exa-apath:guide:multiple properties] __br__ [wb-ra:guide:multiple properties]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>selects all properties with names according to a regular expression: <code>[exa-result:guide:multiple properties]</code>. <sup>2</sup></p> <pre><code>[exa-apath:guide:array items]   and   [exa-apath:guide:property values] __br__ [wb-ra:guide:array items]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>selects all array items and property values and results in <code>[exa-result:guide:array items]</code> and <code>[exa-result:guide:property values]</code>, respectively.</p> <pre><code>[exa-apath:guide:filter]  [wb-ra:guide:filter]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>selects inventory items restricted to dates and an item category and calculates their total prices. The total prices is <code>[exa-result:guide:filter]</code>.</p> <p></p> <pre><code>[exa-apath:guide:regex match] [wb-ra:guide:regex match]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>selects all items purchased in any October and calculates their total prices The output contains the date inherited from the inventory property. For this purpose, the inventory date is assigned to the variable <code>d</code> and used later.</p> <pre><code>[exa-result:guide:regex match]\n</code></pre> <p>The following example make use of the object returned by the <code>match</code> function.</p> <pre><code>[exa-apath:guide:regex groups] [wb-ra:guide:regex groups]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>The first line yields the object <code>{\"groups\": [\"Berlin, Germany\",\"Berlin\",\"Germany\"]}</code> that contains the regex groups from which the result <code>[exa-result:guide:regex groups]</code> is built.</p>"},{"location":"language/guide.html#construction-transformation","title":"Construction &amp; Transformation","text":"<pre><code>[exa-apath:guide:object construction] [wb-ra:guide:object construction]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>constructs a json object as the result instead of a string (see previous example):</p> <pre><code>[exa-result:guide:object construction]\n</code></pre> <p>In some applications it can happen that property names are not fixed and contain information that is otherwise given as a value. Furthermore, transformations are based on embedding input objects into the output:</p> <pre><code>[exa-apath:guide:dynamic name / embedding] [wb-ra:guide:dynamic name / embedding]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>transforms the running example into an object that has the top property name stemming from a property value, using the parenthesized expression <code>(name)</code>. The <code>flatOwner</code> is embedded (<code>_</code>), the <code>location</code> modified, and some properties are removed:</p> <pre><code>[exa-result:guide:dynamic name / embedding]\n</code></pre> <p>The expression</p> <pre><code>[exa-apath:guide:classical merge] [wb-ra:guide:classical merge]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>performs the classical merge of multiple objects and has output </p> <pre><code>[exa-result:guide:classical merge]\n</code></pre> <p>A conditional embedding</p> <pre><code>[exa-apath:guide:conditional embedding] __br__ [wb-ra:guide:conditional embedding]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>has output <code>[exa-result:guide:conditional embedding]</code>.</p> <p>Conditionals plays an important role, not only in the form of filters, introduced earlier. The following example places a condition within a filter. Furthermore, the embedding of sequences in arrays is used. This is also called list comprehension in other functional languages. </p> <pre><code>[exa-apath:guide:nested conditional] [wb-ra:guide:nested conditional]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <p>stores the car in a variable for later use, and then builds the array by iterating over the inventory items and filtering them according to the quantity and the car. The filter is dynamically evaluated via the variable <code>heavyCar</code>. It yields output</p> <pre><code>[exa-result:guide:nested conditional]\n</code></pre> <p>Last, but not least, variables can also store sequences. In the following, two sequences are assigned to variables. Afterwards, a 'join' is performed on the names of the elements, and again embedded in an array.</p> <pre><code>[exa-apath:guide:join] [wb-ra:guide:join]\n</code></pre> <p> (1) </p> <ol> <li>[snippet:doc-exa-snippet-2:none]</li> </ol> <pre><code>[exa-result:guide:join]\n</code></pre> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>here '+' is the concatenation of strings.\u00a0\u21a9</p> </li> <li> <p>Multiple results are delimited by comma.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/intro.html","title":"Intro","text":"<p>For now, language description consists of</p> <ul> <li>a cheat sheet</li> <li>a guide</li> <li>language elements by means of railroad diagrams</li> <li>programmatic use of the javascript API</li> </ul> <p>Throughout the documentation, icon  references the related cheat-sheet parts,  related grammar elements,  the (semi-formal) semantics, and [wb:basic:property] the workbench.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/preliminaries.html","title":"Preliminaries","text":"<p>In the following, we provide basic definitions used throughout the documentation, that are intended to aid understanding of the language elements.<sup>1</sup></p> <ul> <li>A string, number, boolean, or null is called [[atomic node]] (e. g. <code>1</code>, <code>'hello'</code>, <code>true</code>), an object or array is called [[structured node]] (e. g. <code>{a:1}</code>, <code>[1,2]</code>).</li> <li>A [[node]] is either an atomic or structured node.</li> <li>A [[sequence]] (of nodes) is an ordered collection of zero or more nodes. </li> <li>A sequence consisting of exactly one node is called a [[singleton]]. A node is identical to a singleton that contains that node.</li> <li>A sequence with zero nodes is called an [[empty sequence]].</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>We partly align to the xpath terminology.\u00a0\u21a9</p> </li> </ol>"},{"location":"language/programatic.html","title":"Programmatic Use","text":"<p>For now, the workbench site contains two bundles (generated by rollup):</p> <ul> <li><code>workbench/programmatic/apath-lib-es.js</code> for ES-compliant use and</li> <li><code>workbench/programmatic/apath-lib-cjs.js</code> for CommonJs-compliant use</li> </ul> <p>The following program exemplifies the usage of the API.</p> <pre><code>import { Apath } from './apath-lib-es.js'\n\n// a step func\nfunction f(ctx_node) {\n    return ctx_node + 1\n}\n\nconst apath = new Apath()\n\n// adding the step func\napath.step_func(f)\n\n// get the evaluator\nconst evaluator = apath.transpile('a.b.f()')\n\n// evaluate\nconst result = Array.from(evaluator.evaluate_json('{ \"a\": { \"b\": 1 } }'))\n\n// show result\nconsole.log(JSON.stringify(result)) // [2]\n\n// or in one expression\nconsole.log(\n    JSON.stringify(\n        Array.from(\n            new Apath().step_func(f).transpile('a.b.f()')\n                .evaluate_json('{ \"a\": { \"b\": 1 } }'))))\n</code></pre>"},{"location":"language/roadmap.html","title":"News & Roadmap","text":""},{"location":"language/roadmap.html#news","title":"News","text":"feature / construct / doc kind remark id grammar / workbench / section guide new doc section: guide with running example R6 see guide programmatic use new doc section with API use R6 see programmatic use (semi-formal) semantics new doc section with processing table R6 see evaluation variables new variable declaration in scope expressions R5 match values new step function regex match for values R4 workbench store/restore new (re-)storing widgets locally R3 see workbench property literal changed resolved ambiguity for string literals in paths and expressions (<code>`...`</code>) R2 arithmetic new + - * / % - operators R1"},{"location":"language/roadmap.html#roadmap","title":"Roadmap","text":"<p>The following constructs/functionality are planned (not ordered by priority).</p> <ul> <li> variables</li> <li>(recursive) apath step functions</li> <li>rhs paths in assignments</li> <li>(composite) step enhancement<ul> <li>object-split</li> <li> regex over values</li> <li>operator to process sequences (sort, reduce)</li> </ul> </li> <li>expressions<ul> <li> arithmetic </li> <li>some, every, union</li> </ul> </li> <li>pattern matching</li> <li>logical constraints</li> <li>...</li> </ul> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"language/step-functions.html","title":"Step Functions","text":"<p>Step functions support the reuse of functionality and the building of custom language elements. Especially the latter one is essential for building domain specific languages. [sheet:javascript-step-functions-user-defined]</p> <p>Step functions are divided in</p> <ul> <li>apath functions that enable (parametrizable) reuse of expressions</li> <li>javascript functions (the current host language) that enable functionality (so far) not expressable with apath, and the invocation of other services.</li> </ul>"},{"location":"language/step-functions.html#apath-functions","title":"apath functions","text":"<p>...forthcoming...</p>"},{"location":"language/step-functions.html#javascript","title":"Javascript","text":"<p>Step functions have to conform to the following form: </p> <pre><code>function &lt;func-id&gt;(ctx_node, arg1, ... , argN) {\n    // ... process context node 'ctx_node' and arguments\n    // ... possibly check an argument with 'apart.isApathIterable(argI)'\n    // ... create return value r that is an \n    // *apath-js-iterable*, *undefined* or other javascript value \n    return r\n}\n</code></pre> <p>where the first parameter <code>ctx_node</code> is the context node passed from path evaluation. An argument <code>argI</code> is either a [[#node]] or an apath-js-iterable that represents [sequences][[#sequence]].</p> <p>The return value <code>r</code> must be either a [[#node]], an apath-js-iterable, or undefined.</p> <p>\\(x\\) is [[apath-js-iterable]] if</p> <ul> <li>\\(x\\) is neither null, undefined, a string, or an array, and</li> <li>\\(x\\) is javascript-iterable (see Iteration protocols)</li> </ul> <p>To check wether an argument <code>argI</code> is apath-js-iterable, the runtime function <code>isApathIterable</code> can be used. [sheet:e-with sequences as parameters]</p> <p>The return value undefined indicates that no solution exists. In this case, at the path evaluation component, no further steps are performed, and the path has no solution [sheet:e-simple step function]. It is semantically equivalent to returning an [[#empty sequence]].</p>"},{"location":"language/variables.html","title":"Variables","text":"<p>Variables enables the reuse of values.  </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"performance/performance-1.html","title":"Performance","text":""},{"location":"performance/performance-1.html#techniques","title":"Techniques","text":"<p>Of course, a complex selection and transformation language will always result in additional evaluation time in comparison to writing raw code in the host language. Our target is, at least, to reach an evaluation performance factor of \\(\\leq 5\\) (in relation to raw code).<sup>1</sup> In general, performance is enhanced by</p> <ul> <li>taking the compilation approach to avoid AST interpretation</li> <li>not wrapping all evaluation nodes as sequences, instead passing through single objects </li> <li>not materializing sequences (as arrays), instead only use of iterators  </li> <li>inlining expressions to a great extent </li> </ul>"},{"location":"performance/performance-1.html#benchmarks","title":"Benchmarks","text":"<p>... forthcoming ...</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <ol> <li> <p>For instance, first tests with simple paths like <code>a.b.c</code> yield a performance overhead of ~2.5 compared with pure javascript (first 'inlining' experiments even yield factor 1.3). This correlates with the typical range of 1.5 to 5 comparing functional and imperative languages like Haskell resp. C++.\u00a0\u21a9</p> </li> </ol>"},{"location":"workbench/workbench.html","title":"Workbench","text":""},{"location":"workbench/workbench.html#main-window","title":"Main Window","text":"<p>The workbench (see  ) can be used to interactively explore apath language constructs. As seen below, it consists of a control panel and four (resizable and draggable) widgets for</p> <ul> <li>json input</li> <li>(optional) javascript step function</li> <li>apath expression</li> <li>result of the evaluation</li> </ul> workbench main window <p>Initially, the first example of the choosen topic is shown (see control panel). All cheat-sheet examples are taken from the topic <code>basic</code>.</p>"},{"location":"workbench/workbench.html#control-panel","title":"Control Panel","text":"<p>The control panel offers various exploration and information functions.</p> control panel <ul> <li><code>examples</code>: step by step examples<ul> <li>categorized by topic (e. g. <code>basic</code>)</li> <li>example per topic (e. g. <code>property</code>)</li> </ul> </li> <li><code>widgets</code><ul> <li><code>store</code>: stores content of the widgets locally (control panel is not stored)</li> <li><code>restore</code>: restores the widgets</li> <li><code>dark</code> mode for the widgets</li> </ul> </li> <li><code>control</code><ul> <li><code>eval</code>: evaluation of the apath expression</li> <li><code>live eval</code>: evaluation on typing</li> <li><code>strict failure</code>: strict failure instead of 'no solutions'<sup>1</sup>.</li> </ul> </li> <li><code>info</code>: opens the documentation (<code>doc</code>), the abstract syntax tree (<code>AST</code>) of the apath expression, the description by <code>grammar</code>, or the <code>cheat-sheet</code> in a separate browser window. The grammar and cheat-sheet parts correspond to the selected <code>basic</code> example</li> </ul> <ol> <li> <p>When the evaluation of a path has no solution, the reason for that could be an erroneous path definition. For instance, for the input <code>{a: 1}</code> the property selection <code>aa</code> yields no solution. If <code>strict failure</code> is enabled an error message is returned. This is only useful in the testing phase.\u00a0\u21a9</p> </li> </ol>"}]}